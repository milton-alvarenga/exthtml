import fs from 'fs/promises';
import path from 'path';
import { parse } from "../parse/exthtml/parser_exthtml.js"
import { parseStyle, updateNames, ast2strCss } from "../parse/css/parser_css.js"
import { parseScript, parseCode, createSetReactiveNode, createCheckReactiveNode, parseEventDescription } from "../parse/js/parser_js.js"
import * as macro from "./directives/macro.js"
import * as drall from "./directives/drall.js"
import * as customAttr from "./attributes/custom.js"
import * as estreewalker from 'estree-walker';
import * as escodegen from 'escodegen';
import * as periscopic from 'periscopic';
import * as knownGlobals from './tools/knownGlobals.js';
import { locate } from 'locate-character';
import MagicString from 'magic-string';
import { inspect } from 'util';
import { getStructure } from './internals/analyze.js'
import * as codeUtils from './tools/codeUtils.js'

//import { style } from "../analyse/exthtml/directives/style";

let __VERSION__ = '0.0.2'
const BANNER = `//Generated by ExtHTML v${__VERSION__}`

let elem_counter = 1

export async function exthtmlCompileFile(filePath) {
    const source_code_content = await fs.readFile(filePath, 'utf8');
    try {
        return exthtmlCompile(source_code_content, filePath);
    } catch (err) {
        if (!Array.isArray(err.errors)) {
            err.errors = [err];
        }
        err.errors.unshift(new Error(`Error on file ${filePath}`))

        throw new AggregateError(err.errors)
    }
}


export function exthtmlCompile(source_code_content, filePath) {
    const ast = parse(source_code_content);

    let { scripts = [], exthtml = [], styles = [] } = extract_sfc_contents_parts(ast)
    //console.log(inspect(exthtml, { depth: null, colors: true, showHidden: true }));
    let parsedOutput = parseScriptsAndStylesTags(scripts, styles)
    scripts = parsedOutput[0]
    styles = parsedOutput[1]
    //console.log(inspect(scripts, { depth: null, colors: true, showHidden: true }));
    const analysis = analyse(exthtml, scripts, styles, filePath)
    //console.log(inspect(analysis, { depth: null, colors: true }))
    const generated_ctx = generateCtx(scripts, analysis)
    const generate_code = generate4Web(scripts, styles, analysis)
    return [scripts, exthtml, styles, generate_code, generated_ctx]
    return { ast: JSON.stringify(ast, null, 4) }
}

function extract_sfc_contents_parts(ast) {
    let scripts = []
    let exthtml = []
    let styles = []

    extractor_sfc_walker(ast, scripts, exthtml, styles)

    return { scripts, exthtml, styles }
}

function parseScriptsAndStylesTags(scripts, styles) {

    for (let x = 0; x < scripts.length; x++) {
        scripts[x].children = parseScript(scripts[x])
    }
    for (let x = 0; x < styles.length; x++) {
        styles[x].children = parseStyle(styles[x])
    }

    return [scripts, styles]
}

//https://www.perplexity.ai/search/program-structure-program-bloc-5ZZ_Sz1qS3K.m2rsWCXETg
function analyse(exthtml, scripts, styles, filePath) {
    /*
            let vars = {
                count: {
                    v:[0],
                    dependencies:{
                        variable:[],
                        components:[],
                        directives:[]
                    },
                    dependents:{
                        variable:[],
                        components:[],
                        directives:[]
                    }
                }
            };
    
            let dirty_queue = [
                {
                    target_var:
                    generated_by:
                }
            ]
    */
    const result = getStructure()
    for (let x = 0; x < styles.length; x++) {
        if (styles[x].value) {
            result.cssTree = updateNames(styles[x])
            if (filePath) {
                if (x > 0) {
                    continue
                }
                let baseName = path.basename(filePath, path.extname(filePath)) // get name without extension
                baseName += '.css'; // add .css extension
                result.code.internal_import.add('addCssLinkOnHead')
                result.code.internal_import.add('removeCssLinkFromHead')
                result.code.create.push(`$$_addCssLinkOnHead('/${baseName}')`)
                result.code.destroy.push(`$$_removeCssLinkFromHead('/${baseName}')`)
                result.code.imports.push(`import 'virtual:${baseName}'`)
            } else {
                //Must to be inline css as we did not know the component path
                result.code.internal_import.add("el")
                result.code.internal_import.add("setAttr")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")

                let varname = '$$style_1'
                result.code.elems.push(varname)
                result.code.create.push(`${varname} = $$_el('style')`)
                //result.code.create.push(`$$_setAttr(${variableName}, 'textContent', '${styles[x].value}'`)
                result.code.create.push(`$$_setAttr(${variableName}, 'textContent', '${ast2strCss(styles[x].children)}'`)
                result.code.mount.push(`$$_append(TARGET,${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
            }
        }
    }

    const reactiveDeclarations = []
    const toRemove = new Set()

    for (let x = 0; x < scripts.length; x++) {
        script_pre_analyse(scripts[x], result)
        const { scope: rootScope, map, globals } = periscopic.analyze(scripts[x].children)
        result.declared_variables = new Set(rootScope.declarations.keys())
        result.undeclared_variables = Array.from(globals.keys()).filter(v => !(knownGlobals.functions.has(v) || knownGlobals.objects.has(v)));
        //console.log(inspect(scripts[x].children.body, { depth: null, colors: true }));

        /*
        scripts[x].children.body.forEach((node, index) => {
            if (node.type === 'LabeledStatement' && node.label.name === '$') {
                toRemove.add(node);
                const body = node.body;
                const left = body.expression.left;
                const right = body.expression.right;
                const dependencies = [];

                estreewalker.walk(right, {
                    enter(node) {
                        if (node.type === 'Identifier') {
                            dependencies.push(node.name);
                        }
                    },
                });
                result.willChange.add(left.name);
                const reactiveDeclaration = {
                    assignees: [left.name],
                    dependencies: dependencies,
                    node: body,
                    index,
                };
                reactiveDeclarations.push(reactiveDeclaration);
            }
        });


        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (node.type === 'LabeledStatement' && node.label.name === '$') {
                    // Replace the labeled statement node in the parent's body with the inner statement
                    if (parent && Array.isArray(parent.body)) {
                        const index = parent.body.indexOf(node);
                        if (index !== -1) {
                            parent.body.splice(index, 1, node.body);
                            // Stop walking this replaced node to avoid confusion
                            this.skip();
                        }
                    } else if (parent && parent.type === 'Program') {
                        // If parent is Program, replace in its body array
                        const index = parent.body.indexOf(node);
                        if (index !== -1) {
                            parent.body.splice(index, 1, node.body);
                            this.skip();
                        }
                    }
                }
            }
        });

        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (node.type === 'LabeledStatement' && node.label.name === '$') {
                    if (parent && Array.isArray(parent)) {
                        const index = parent.indexOf(node);
                        if (index !== -1) {
                            // Assuming node.body is an ExpressionStatement or similar
                            // Extract expression from node.body
                            let initExpression = null;
                            if (node.body.type === 'ExpressionStatement') {
                                initExpression = node.body.expression;
                            } else if (node.body.type === 'Literal' || node.body.type.endsWith('Expression')) {
                                initExpression = node.body;
                            } else {
                                // If node.body is a block or other statement, you need to handle differently
                                // For now, skip or throw error
                                this.skip();
                                return;
                            }

                            // Create a VariableDeclaration node
                            const varDecl = {
                                type: 'VariableDeclaration',
                                kind: 'let',
                                declarations: [{
                                    type: 'VariableDeclarator',
                                    id: { type: 'Identifier', name: 'x' }, // You can change 'x' to any variable name you want
                                    init: initExpression,
                                }]
                            };
console.log(inspect(parent, { depth: null, colors: true }));
                            // Replace the labeled statement with the new let declaration
                            parent.splice(index, 1, varDecl);
console.log("------------")
console.log(inspect(parent, { depth: null, colors: true }));
                            this.skip();
                        }
                    }
                }
            }
        });
*/

        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (parent !== null) {
                    // We are at a child node (first level), so skip its children
                    this.skip();
                }

                // Check if node is a FunctionDeclaration and its parent is Program (global scope)
                if (node.type === 'FunctionDeclaration') {
                    result.functions.add(node.id.name)
                } else if (
                    node.type === 'VariableDeclaration'
                    &&
                    node.declarations
                ) {
                    node.declarations.forEach(decl => {
                        if (
                            decl
                            &&
                            decl.init
                            &&
                            (
                                decl.init.type === 'FunctionExpression'
                                ||
                                decl.init.type === 'ArrowFunctionExpression'
                            )
                        ) {
                            result.functions.add(decl.id.name);
                        }
                    })
                }
            }
        });



        //scripts[x].children.body = scripts[x].children.body.filter((node) => !toRemove.has(node))
        result.reactiveDeclarations = reactiveDeclarations

        estreewalker.walk(scripts[x].children, {
            enter(node, parent) {
                // should now show the Program node for top-level nodes
                if (
                    node.type === 'VariableDeclaration'
                    &&
                    parent.type === 'Program'
                ) {
                    node.declarations.forEach(decl => {
                        if (result.functions.has(decl.id.name)) {
                            return;
                        }

                        let depVar = result.dependencyTree.get(decl.id.name);
                        depVar.declarationType = node.kind;
                        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${decl.id.name}')`)
                        result.code.dependencyTree.push(`$$_depVar.declarationType = '${node.kind}'`)
                        let has_dependency = false;
                        if (decl.init) {
                            estreewalker.walk(decl.init, {
                                enter(innerNode) {
                                    if (innerNode.type === 'Identifier') {
                                        has_dependency = true
                                        let _depVar = result.dependencyTree.get(innerNode.name);
                                        _depVar.dependents.variables.add(decl.id.name);
                                        depVar.dependsOn.variables.add(innerNode.name);
                                        result.code.dependencyTree.push(`$$_depVar.dependsOn.variables.add('${innerNode.name}')`)
                                        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${innerNode.name}')`)
                                        result.code.dependencyTree.push(`$$_depVar.dependents.variables.add('${decl.id.name}')`)
                                    }
                                }
                            });
                        }

                        if (node.kind !== 'const' && has_dependency) {
                            // Generate an assignment expression string for the variable initialization:
                            // e.g. "x = 5" or "x = someFunction()"
                            const assignmentAst = {
                                type: 'ExpressionStatement',
                                expression: {
                                    type: 'AssignmentExpression',
                                    operator: '=',
                                    left: decl.id,
                                    right: decl.init || { type: 'Identifier', name: 'undefined' }
                                }
                            };

                            const assignmentCode = escodegen.generate(assignmentAst);

                            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${decl.id.name}')`)

                            // Push the recalculate function that reassigns the variable                            
                            result.code.dependencyTree.push(`$$_depVar.recalculate.push(() => { ${assignmentCode} })`);
                        }

                        // Insert a new statement after this VariableDeclaration node
                        const setReactiveNode = createSetReactiveNode(decl.id.name);

                        // Find the index of the current VariableDeclaration node in parent's body
                        const index = parent.body.indexOf(node);

                        // Insert the setReactive statement right after in the parent's body array
                        if (index !== -1) {
                            parent.body.splice(index + 1, 0, setReactiveNode);
                        }
                    });
                }
            }
        });

        let currentScope = rootScope
        let closestBodyParentStack = [];
        let parentStack = [];
        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                parentStack.push(node);
                // Track the current body context for potential insertions
                if (node.body && Array.isArray(node.body)) {
                    closestBodyParentStack.push(node);
                }
                // Update current scope from scope map
                if (map.has(node)) currentScope = map.get(node);

                if (
                    //An UpdateExpression (e.g., x++ or --y)
                    node.type === 'UpdateExpression'
                    ||
                    //An AssignmentExpression (e.g., x = 5 or y += 2)
                    node.type === 'AssignmentExpression'
                ) {
                    const names = periscopic.extract_names(
                        node.type === 'UpdateExpression' ? node.argument : node.left
                    );
                    for (const name of names) {
                        if (
                            currentScope.find_owner(name) === rootScope
                            ||
                            globals.has(name)
                        ) {
                            result.willChange.add(name);

                            // Insert a new statement after this VariableDeclaration node or Update expression
                            const checkReactiveNode = createCheckReactiveNode(name);

                            // Find the closest parent statement in parentStack
                            const enclosingStmt = parentStack
                                .slice() // make a copy
                                .reverse()
                                .find(n =>
                                    n && n.type && n.type.endsWith('Statement') &&
                                    closestBodyParentStack[closestBodyParentStack.length - 1]?.body?.includes(n)
                                );

                            const closestParent = closestBodyParentStack[closestBodyParentStack.length - 1];

                            if (enclosingStmt && closestParent) {
                                const body = closestParent.body;
                                const index = body.indexOf(enclosingStmt);
                                if (index !== -1) {
                                    body.splice(index + 1, 0, checkReactiveNode);
                                }
                            }
                        }
                    }
                }

                if (
                    node.type === "AssignmentExpression"
                    &&
                    node.left.type === "MemberExpression"
                ) {
                    let name = null;
                    //It is an Array or object on pattern obj[attr]
                    if (node.left.computed) {
                        // This is like arr[4] = ...
                        //console.log("Array index assignment detected:", node.left.object.name, "[...]", "at position", node.left.property.value);
                        name = node.left.object.name
                        //It is an object on pattern obj.attr
                    } else {
                        // This is like obj.a = ...
                        //console.log("Object property assignment detected:", node.left.object.name, ".", node.left.property.name);
                        name = node.left.object.name
                    }

                    if (
                        name
                        &&
                        (
                            currentScope.find_owner(name) === rootScope
                            ||
                            globals.has(name)
                        )
                    ) {
                        result.willChange.add(name);
                        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${name}')`)
                        const assignmentCode = escodegen.generate(node);

                        // Push the recalculate function that reassigns the variable
                        result.code.dependencyTree.push(`$$_depVar.recalculate.push(() => { ${assignmentCode} })`);

                        estreewalker.walk(node.right, {
                            enter(node) {
                                if (
                                    node.type === 'Identifier'
                                    &&
                                    (
                                        currentScope.find_owner(node.name) === rootScope
                                        ||
                                        globals.has(node.name)
                                    )

                                ) {
                                    let _depVar = result.dependencyTree.get(node.name);
                                    _depVar.dependents.variables.add(name);
                                    _depVar.dependsOn.variables.add(node.name);
                                    result.code.dependencyTree.push(`$$_depVar.dependsOn.variables.add('${node.name}')`);
                                    result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${node.name}')`);
                                    result.code.dependencyTree.push(`$$_depVar.dependents.variables.add('${name}')`);
                                }
                            }
                        });
                    }
                }
            },
            leave(node) {
                if (map.has(node)) currentScope = currentScope.parent;

                if (node.body && Array.isArray(node.body)) {
                    closestBodyParentStack.pop();
                }
            },
        });

        /*
        console.log(inspect(scope, { depth: null, colors: true, showHidden: true }));
        console.log(inspect(map, { depth: null, colors: true, showHidden: true }));
        console.log(inspect(globals, { depth: null, colors: true, showHidden: true }));
        */
        //console.log(inspect(result, { depth: null, colors: true, showHidden: true }))
        script_pos_analyse(scripts[x], result)
    }

    exthtml.forEach(node => traverseExthtml(node, result, 'TARGET'))

    return result
}

function script_pre_analyse(script, result) {

}

function removeDuplicateCheckReactiveDeep(node, lastFound) {
    if (!node || typeof node !== 'object') return;

    lastFound = lastFound || "";
    // Check keys for arrays or objects and recurse
    for (const key in node) {
        if (Array.isArray(node[key])) {
            // For arrays of nodes, filter duplicates then recurse into each node
            if (key === 'body' || key === 'consequent' || key === 'alternate' || key === 'block' || key === 'handlers') {
                const seenVarNames = new Set();
                node[key] = node[key].filter(child => {
                    if (
                        child.type === 'ExpressionStatement'
                        &&
                        child.expression.type === 'CallExpression'
                        &&
                        child.expression.callee.type === 'Identifier'
                        &&
                        child.expression.callee.name === '$$_checkReactive'
                        &&
                        child.expression.arguments.length === 4
                        &&
                        child.expression.arguments[0].type === 'Literal'
                    ) {
                        const varName = child.expression.arguments[0].value;
                        if (lastFound == varName) {
                            return false; // remove duplicate
                        } else {
                            lastFound = varName
                            return true;
                        }
                    }
                    lastFound = ""
                    return true;
                });
            }
            // Recurse into each item in the array
            node[key].forEach(child => removeDuplicateCheckReactiveDeep(child, lastFound));
        } else if (node[key] && typeof node[key] === 'object') {
            // Recurse into nested AST nodes
            removeDuplicateCheckReactiveDeep(node[key], lastFound);
        }
    }
}

function script_pos_analyse(script, result) {
    removeDuplicateCheckReactiveDeep(script.children)

    if (script.attrs.some(attr => attr.name == 'context' && attr.value === 'module')) {
        result.code.shared_state.push(escodegen.generate(script.children))
        return
    }
}

function traverseExthtml(exthtml, result, parent_nm) {
    let variableName = ''
    let reactiveFnName = ''
    try {
        switch (exthtml.type) {
            case 'NEW_LINE':
            case 'SINGLE_LINE_COMMENT':
            case 'MULTIPLE_LINE_COMMENT':
            case 'COMMENT_TEXT':
            case 'SCRIPT_TAG':
            case 'STYLE_TAG':
                return
            case 'DYNAMIC_TEXT_NODE':
                result.code.internal_import.add("text")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                variableName = `$$dyn_txt_${elem_counter++}`
                reactiveFnName = `${variableName}__textContent`
                result.code.elems.push(variableName)
                result.code.create.push(`${variableName} = $$_text(${codeUtils.escapeNewLine(exthtml.value)})`)
                let usedVars = extract_relevant_js_parts_evaluated_to_string(exthtml.value, result)
                for (const v of usedVars) {
                    let depVar = result.dependencyTree.get(v)
                    depVar.dependents.texts.add(reactiveFnName)
                    result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
                    result.code.dependencyTree.push(`$$_depVar.dependents.texts.add(${reactiveFnName})`)
                }
                result.code.reactives.push(`function ${reactiveFnName}(){${variableName}.textContent = ${exthtml.value}}\n`)
                result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
                return

            case 'TEXT_NODE':
                result.code.internal_import.add("text")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                variableName = `$$txt_${elem_counter++}`
                result.code.elems.push(variableName)
                result.code.create.push(`${variableName} = $$_text('${codeUtils.escapeNewLine(exthtml.value)}')`)
                result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
                return

            case 'TEXTAREA_TAG':
                variableName = `$$textarea_${elem_counter++}`
                break
            case 'TITLE_TAG':
                variableName = `$$textarea_${elem_counter++}`
                break
            case 'PLAINTEXT_TAG':
                variableName = `$$plaintext_${elem_counter++}`
                break
            case 'HTML_NESTED_TAG':
                variableName = `$$${exthtml.value.toLowerCase()}_${elem_counter++}`
                break
            case 'SELF_CLOSE_TAG':
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                result.code.internal_import.add("el")
                variableName = `$$${exthtml.value.toLowerCase()}_${elem_counter++}`
                result.code.elems.push(variableName)
                result.code.create.push(`${variableName} = $$_el('${exthtml.value.toLowerCase()}')`)
                exthtml.attrs.forEach(attr => traverseExthtmlAttr(attr, "STATIC", result, variableName, exthtml, parent_nm))
                exthtml.dynamic_attrs.forEach(dynamicAttr => traverseExthtmlAttr(dynamicAttr, "DYNAMIC", result, variableName, exthtml, parent_nm))
                exthtml.event_attrs.forEach(eventAttr => traverseExthtmlEventAttr(eventAttr, "DYNAMIC", result, variableName, parent_nm))
                result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
                return
            case 'COMPONENT':

                break
            default:
                throw Error(`${traverseExthtml.name} Error on unexpected type equal ${exthtml.type} and value ${exthtml.value} at line ${exthtml.location.line}`)
        }

        result.code.internal_import.add("el")
        result.code.internal_import.add("append")
        result.code.internal_import.add("detach")
        result.code.elems.push(variableName)

        result.code.create.push(`${variableName} = $$_el('${exthtml.value.toLowerCase()}')`)
        exthtml.children.forEach(node => traverseExthtml(node, result, variableName, parent_nm))
        exthtml.attrs.forEach(attr => traverseExthtmlAttr(attr, "STATIC", result, variableName, exthtml, parent_nm))
        exthtml.dynamic_attrs.forEach(dynamicAttr => traverseExthtmlAttr(dynamicAttr, "DYNAMIC", result, variableName, exthtml, parent_nm))
        exthtml.event_attrs.forEach(eventAttr => traverseExthtmlEventAttr(eventAttr, "DYNAMIC", result, variableName, parent_nm))

        result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
        result.code.destroy.push(`$$_detach(${variableName})`)
    } catch (err) {
        let errors = [err, new Error(`${traverseExthtml.name} Error on ${exthtml.type}.${exthtml.value} at line ${exthtml.location.start.line}`)]
        console.log(errors);
        throw new AggregateError(errors)
    }
}

function traverseExthtmlAttr(attr, mode, result, variableName, node, parent_nm) {
    let aValidMode = ['DYNAMIC', 'STATIC']
    if (!aValidMode.includes(mode)) {
        throw new Error(`Invalid mode: ${mode}. Expected one of: ${aValidMode.join(', ')}`);
    }

    switch (attr.category) {
        case "html_global_boolean_attribute":
        case "html_boolean_attribute":
            htmlBooleanAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_data_attribute":
            htmlDataAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_global_non_boolean_attribute":
        case "html_attribute":
            htmlRegularAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_media_readonly":
        case "html_video_readonly":
            htmlReadOnlyAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "class_directive":
            htmlClassDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "lang_directive":
            htmlLangDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "custom_attribute":
            htmlCustomAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "drall_directive":
            htmlDrallDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "macro_directive":
            htmlMacroDirective(attr, mode, result, variableName, node, parent_nm)
            break
        default:
            throw Error(`${traverseExthtmlAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is of category ${attr.category} not recognized`)
    }
}

function checkMode(mode) {
    let aValidMode = ['DYNAMIC', 'STATIC']

    if (!aValidMode.includes(mode)) {
        throw new Error(`Invalid mode: ${mode}. Expected one of: ${aValidMode.join(', ')}`);
    }
}

function traverseExthtmlEventAttr(eventAttr, mode, result, variableName, parent_nm) {
    checkMode(mode)

    if (mode != "DYNAMIC") {
        throw new Error(`Invalid mode: ${mode} for extHTML event Attribute.}`);
    }


    let modifierChecks = '';
    if (eventAttr.keyboard_modifiers_keys && eventAttr.keyboard_modifiers_keys.length > 0) {
        const mods = eventAttr.keyboard_modifiers_keys.map(key => `event.${key}Key`).join(' && ');
        modifierChecks = mods ? `if (!(${mods})) return;` : '';
    }

    // Build mouse key check if applicable
    let mouseKeyCheck = '';
    if (eventAttr.mouse_keys) {
        // For example, left mouse button check: event.button === 0
        // Map mouse_keys string to event.button number:
        const mouseButtonMap = {
            left: 0,
            middle: 1,
            right: 2
        };
        const btnCode = mouseButtonMap[eventAttr.mouse_keys.toLowerCase()];
        if (btnCode !== undefined) {
            mouseKeyCheck = `if (event.button !== ${btnCode}) return;`;
        }
    }

    let reactiveFnName = `${variableName}__handlerCode`


    let descriptors = parseEventDescription(eventAttr.value)

    let handlerCode = ''
    if (['functionName', 'functionCall'].indexOf(descriptors.type) > -1) {
        //Has the function been declared?
        if (!result.functions.has(descriptors.name)) {
            throw Error(`${traverseExthtmlEventAttr.name} function: Invalid ${descriptors.type.toLowerCase()} attribute on ${attr.name} and its value as ${attr.value}`)
        }

        if (descriptors.type == 'functionName') {
            // Compose the full event handler code snippet
            // DYNAMIC mode: eventAttr.value is an expression to be evaluated at runtime
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    (${eventAttr.value}) && (${eventAttr.value})(event)
                }
            `.replace(/^\s*[\r\n]/gm, '');
        } else {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    (${descriptors.name}) && (${eventAttr.value})
                }
            `.replace(/^\s*[\r\n]/gm, '');
        }
    } else if (descriptors.type == 'functionCallWithParams') {
        if (!result.functions.has(descriptors.name)) {
            throw Error(`${traverseExthtmlEventAttr.name} function: Invalid ${descriptors.type.toLowerCase()} attribute on ${attr.name} and its value as ${attr.value}`)
        }
        // Compose the full event handler code snippet
        // DYNAMIC mode: eventAttr.value is an expression to be evaluated at runtime
        handlerCode = `
            function ${reactiveFnName}(event) {
                ${modifierChecks}
                ${mouseKeyCheck}
                //if want the event, need to add on parameter as event (not string)
                (${descriptors.name}) && (${descriptors.name})(${descriptors.parameters.join(',')})
            }
        `.replace(/^\s*[\r\n]/gm, '');
    } else if (descriptors.type == 'assignment') {
        // Insert a new statement after this VariableDeclaration node
        let reactive = [descriptors.variableChanged].filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
        handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    ${eventAttr.value}
                    ${reactive}
                }
            `.replace(/^\s*[\r\n]/gm, '');

    } else if (descriptors.type == 'arrowFunction') {
        let ast = parseCode(descriptors.rawBody)
        const { scope: rootScope, map, globals } = periscopic.analyze(ast)
        let reactive = Array.from(globals.keys()).filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
        if (descriptors.parameters.length) {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    let $$_arrowfn = (${descriptors.parameters.join(',')})=>${descriptors.rawBody};
                    $$_arrowfn(${descriptors.parameters.join(',')});
                    ${reactive}
                }
            `.replace(/^\s*[\r\n]/gm, '');
        } else {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    let $$_arrowfn = (event)=>${descriptors.rawBody};
                    $$_arrowfn(event);
                    ${reactive}
                }
            `.replace(/^\s*[\r\n]/gm, '');
        }
    } else if (descriptors.type == 'updateExpression') {
        // Insert a new statement after this VariableDeclaration node
        let reactive = [descriptors.variableChanged].filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
        handlerCode = `
            function ${reactiveFnName}(event) {
                ${modifierChecks}
                ${mouseKeyCheck}
                ${eventAttr.value}
                ${reactive}
            }
        `.replace(/^\s*[\r\n]/gm, '');
    } else {
        handlerCode = `
            function ${reactiveFnName}(event) {
                ${modifierChecks}
                ${mouseKeyCheck}
                (${eventAttr.value}) && (${eventAttr.value})(event)
            }
        `.replace(/^\s*[\r\n]/gm, '');
    }

    result.code.reactives.push(`${handlerCode.trim()}\n`)
    result.code.mount.push(`${variableName}.addEventListener('${eventAttr.name}', ${reactiveFnName})`);
    result.code.destroy.push(`${variableName}.removeEventListener('${eventAttr.name}', ${reactiveFnName})`);
}


function htmlBooleanAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    result.code.internal_import.add("setAttr")
    result.code.internal_import.add("rmAttr")

    if (mode == "STATIC") {
        result.code.create.push(`('${attr.value}') ? $$_setAttr(${variableName}, '${attr.name}', '${attr.value}') : $$_rmAttr(${variableName}, '${attr.name}')`)
    } else {
        let reactiveFnName = `${variableName}__${attr.name}`
        let usedVars = extract_relevant_js_parts_evaluated_to_boolean(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
            result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
        }
        result.code.reactives.push(`function ${reactiveFnName}(){\n
            (${attr.value}) ? $$_setAttr(${variableName}, '${attr.name}', ${attr.value} ? "" : false) : $$_rmAttr(${variableName}, '${attr.name}')
        }`)
        result.code.create.push(`${reactiveFnName}()`)
        //result.code.update.push(`(${attr.value}) ? setAttr(${variableName}, '${attr.name}', ${attr.value}) : rmAttr(${variableName}, '${attr.name}')`)
    }
}

function htmlDataAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    // Data attributes are of the form data-xxx
    // They should be set or removed on the element's dataset property
    // For STATIC mode, attr.value is a literal value (string)
    // For DYNAMIC mode, attr.value is an expression to be evaluated at runtime

    const dataKey = attr.name.slice(5) // remove 'data-' prefix

    if (mode === "STATIC") {
        // For static, check if the value is truthy to set or remove dataset property
        result.code.create.push(`('${attr.value}') ? ${variableName}.dataset['${dataKey}'] = '${attr.value}' : delete ${variableName}.dataset['${dataKey}']`)
    } else {
        result.code.internal_import.add("setAttr")
        result.code.internal_import.add("rmAttr")

        let reactiveFnName = `${variableName}__dataset`

        let usedVars = extract_relevant_js_parts_evaluated_to_string(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
            result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
        }


        // For dynamic, evaluate expression and set or delete accordingly
        //result.code.update.push(`(${attr.value}) ? ${variableName}.dataset['${dataKey}'] = ${attr.value} : delete ${variableName}.dataset['${dataKey}']`)
        result.code.reactives.push(`function ${reactiveFnName}(){(${attr.value}) ? ${variableName}.dataset['${dataKey}'] = ${attr.value} : delete ${variableName}.dataset['${dataKey}']}`)
        result.code.create.push(`${reactiveFnName}()`)
    }
}

function htmlClassDirective(attr, mode, result, variableName, node, parent_nm) {
    if (mode != "DYNAMIC") {
        throw Error(`${htmlClassDirective.name} function: Invalid ${mode.toLowerCase()} attribute on class directive as it is only dynamic attribute`)
    }

    result.code.internal_import.add("rmAttr")

    let reactiveFnName = `${variableName}__${attr.name}`
    let usedVars = extract_relevant_js_parts_evaluated_to_boolean(attr.value, result)
    for (const v of usedVars) {
        let depVar = result.dependencyTree.get(v)
        depVar.dependents.directives.add(reactiveFnName)
        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
        result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
    }

    let className = result.cssTree.classNames.hasOwnProperty(attr.name.trim()) ? result.cssTree.classNames[attr.name.trim()] : attr.name.trim()
    result.code.reactives.push(`function ${reactiveFnName}(){
        (!!(${attr.value})) ? ${variableName}.classList.add('${className}') : ${variableName}.classList.remove('${className}') && ${variableName}.classList.length === 0 && $$_rmAttr(${variableName}, 'class')
    }`)
    result.code.create.push(`${reactiveFnName}()`)
    //class:xxxxxx
    //result.code.update.push(`(!!(${attr.value})) ? ${variableName}.classList.add('${attr.name}'): ${variableName}.classList.remove('${attr.name}')`)
}

function htmlClassAttr(attr, mode, result, variableName, parent_nm) {
    if (mode === "DYNAMIC") {
        let operations = attr.value.split(",")

        operations.forEach(operation => {
            let [_class, expression] = operation.split(":").map(v => v.trim());
            if (!_class) {
                throw Error(`${htmlClassAttr.name} function: Invalid empty class attribute '${operation}'`)
            }
            result.code.internal_import.add("rmAttr")
            let reactiveFnName = `${variableName}__${_class}`
            let usedVars = extract_relevant_js_parts_evaluated_to_boolean(expression, result)
            for (const v of usedVars) {
                let depVar = result.dependencyTree.get(v)
                depVar.dependents.directives.add(reactiveFnName)
                result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
                result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
            }
            let className = result.cssTree.classNames.hasOwnProperty(_class.trim()) ? result.cssTree.classNames[_class.trim()] : _class.trim()
            result.code.reactives.push(`function ${reactiveFnName}(){
                (!!(${expression})) ? ${variableName}.classList.add('${className}') : ${variableName}.classList.length === 1 ? $$_rmAttr(${variableName}, 'class') : ${variableName}.classList.remove('${className}')
            }`)
            result.code.create.push(`${reactiveFnName}()`)

            //result.code.update.push(`(!!(${expression})) ? ${variableName}.classList.add('${_class}'): ${variableName}.classList.remove('${_class}')`)
        });
    } else {
        // Static class attribute: set once on create
        result.code.create.push(`${variableName}.classList.add('${attr.value.split(" ").map(cls => `"${result.cssTree.className[cls.trim()]}"`).join(", ")}')`)
    }
}

function htmlRegularAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)
    // Handle special cases for 'class'
    if (attr.name === 'class') {
        htmlClassAttr(attr, mode, result, variableName, parent_nm)
        return
    }
    //style
    if (attr.name === 'style') {
        handleStyleAttr(attr, mode, result, variableName);
        return;
    }

    result.code.internal_import.add("setAttr")
    result.code.internal_import.add("rmAttr")

    if (mode == "STATIC") {
        result.code.create.push(`('${attr.value}') ? $$_setAttr(${variableName}, '${attr.name}', '${attr.value}') : $$_rmAttr(${variableName}, '${attr.name}')`)
    } else {
        let reactiveFnName = `${variableName}__${attr.name}`

        let usedVars = extract_relevant_js_parts_evaluated_to_string(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
            result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
        }

        result.code.reactives.push(`function ${reactiveFnName}(){
            let cursorPosition
            if ('${node.value}' == 'INPUT' && ${attr.value} && document.activeElement === ${variableName}) {
                cursorPosition = ${variableName}.selectionStart
            };
            (${attr.value}) ? $$_setAttr(${variableName}, '${attr.name}', ${attr.value}) : $$_rmAttr(${variableName}, '${attr.name}');
            if ('${node.value}' == 'INPUT' && ${attr.value} && document.activeElement === ${variableName}) {
                ${variableName}.setSelectionRange(cursorPosition, cursorPosition)
            };
        }`)

        result.code.create.push(`${reactiveFnName}()`)

        //result.code.update.push(`(${attr.value}) ? setAttr(${variableName}, '${attr.name}', ${attr.value}) : rmAttr(${variableName}, '${attr.name}')`)
    }
}

function htmlReadOnlyAttr(attr, mode, result, variableName, node, parent_nm) {
    throw Error(`${htmlReadOnlyAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is readonly attribute`)
}

function htmlCustomAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in customAttr.customAttributes)) {
        throw Error(`${htmlCustomAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is html custom attribute but the compiler could not found it on custom attribute list`)
    }

    customAttr.customAttributes[attr.name](attr, mode, result, variableName, parent_nm)

}

function htmlDrallDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in drall.directives)) {
        throw Error(`${htmlDrallDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    drall.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function htmlMacroDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in macro.directives)) {
        throw Error(`${htmlMacroDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    macro.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function handleStyleAttr(attr, mode, result, variableName) {
    if (mode === "STATIC") {
        // Static style: attr.value is expected to be a string of CSS declarations
        // Just set the whole style attribute once
        result.code.create.push(`${variableName}.setAttribute('style', '${attr.value}')`);
    } else if (mode === "DYNAMIC") {
        // Dynamic style: attr.value can be string, object, or array
        // We'll generate code to update styles individually

        // The dynamic value is expected to be a JS expression (variable or object/array literal)
        const styleVar = attr.value;

        // Generate code that:
        // - clears previous inline styles
        // - iterates over the style declarations and sets/removes styles accordingly

        // We'll generate code that handles three cases:
        // 1. If styleVar is a string: parse by ';' and split by ':'
        // 2. If styleVar is an array: iterate and split each item by ':'
        // 3. If styleVar is an object: iterate keys and values

        // To keep it simple, generate a helper function in update code:

        //@TODO - See all formats and adapt the code
        result.code.update.push(`
            (function() {
                const el = ${variableName};
                // Clear all previous inline styles
                el.style.cssText = '';
                const styleVal = ${styleVar};
                if (typeof styleVal === 'string') {
                    styleVal.split(';').forEach(decl => {
                        const [key, val] = decl.split(':').map(s => s && s.trim());
                        if(key && val) el.style.setProperty(key, val);
                    });
                } else if (Array.isArray(styleVal)) {
                    styleVal.forEach(decl => {
                        const [key, val] = decl.split(':').map(s => s && s.trim());
                        if(key && val) el.style.setProperty(key, val);
                    });
                } else if (typeof styleVal === 'object' && styleVal !== null) {
                    Object.entries(styleVal).forEach(([key, val]) => {
                        if(val != null) el.style.setProperty(key, val);
                    });
                }
            })()
        `);
        //result.code.create.push(`${reactiveFnName}()`)
    }
}

export function extract_relevant_js_parts_evaluated_to_string(code, result) {
    let ast = parseCode(code)
    //console.log(inspect(ast, { depth: null, colors: true }))
    let usedVars = new Set()


    //ExpressionStatement
    estreewalker.walk(ast.body, {
        enter(node) {
            if (node.name) {
                result.willUseInTemplate.add(node.name)
                usedVars.add(node.name)
            }
        }
    })

    return usedVars

    //console.log(inspect(ast, { depth: null, colors: true }))
}

function extract_relevant_js_parts_evaluated_to_boolean(code, result) {
    return extract_relevant_js_parts_evaluated_to_string(code, result)
}


function generateCtx(scripts, analysis) {
    return ''
    return `function ctx(){
        ${Array.from(analysis.undeclared_variables).map((v) => `let ${v};`).join('\n')}
        ${scripts.map(script => escodegen.generate(script.children))}

        return [${[...analysis.declared_variables, ...analysis.undeclared_variables].filter(x => x).join(",")}]
    }
    `
}

//context="module"
function generate4Web(scripts, styles, analysis) {
    //${scripts.filter(script => !script.attrs.some(attr => attr.name === 'context' && attr.value === 'module')).map(script => escodegen.generate(script.children))}
    return `${BANNER}
    import {${Array.from(analysis.code.internal_import).map(name => `${name} as $$_${name}`).join(", ")}} from 'exthtml/src/runtime/dom.js';
    import {setReactive as $$_setReactive, checkReactive as $$_checkReactive} from 'exthtml/src/runtime/reactive2.js';
    import { DependencyTree as $$_DependencyTree } from 'exthtml/src/compiler/internals/variable.js';
    ${analysis.code.imports.join(";\n")};

    // Shared state at the module scope
    ${analysis.code.shared_state.join("\n")}

    export default function(){
        let ${analysis.code.elems.join(',')};

        ${Array.from(analysis.undeclared_variables).map((v) => `let ${v};`).join('\n')}

        let $$_dependencyTree = new $$_DependencyTree();
        let $$_depVar = null;
        let $$changes = new Set();
        let $$_mounted = false;
        let $$_updating = false;

        let $$_changes = function(nm){
            if(!$$_mounted) return;
            $$changes.add(nm)
            if(!$$_updating){
                $$_lifecycle.update();
            }
        }

        ${scripts.filter(script => !script.attrs.some(attr => attr.name === 'context' && attr.value === 'module')).map(script => escodegen.generate(script.children) + '\n').join('')}


        ${analysis.code.reactives.join('\n')}


        ${analysis.code.dependencyTree.join(';\n')};

        let $$_lifecycle = {
            create() {
                ${analysis.code.create.join(';\n')};
            },
            mount(TARGET) {
                this.create();
                ${analysis.code.mount.join(';\n')};
                $$_mounted = true;
            },
            update() {
                if(!$$_mounted) return;
                if($$_updating) return;
                $$_updating = true;
                let $$_done = new Set();
                let $$_recalculate = new Set();
                ${analysis.code.update.join(';\n')}
                let firstElement;
                while(firstElement = $$changes.values().next().value){
                    if($$_done.has(firstElement)){
                        $$changes.delete(firstElement);
                        continue
                    }
                    $$_depVar = $$_dependencyTree.get(firstElement)
                    if($$_recalculate.has(firstElement)){
                        $$_depVar.recalculate.forEach((fn, index) => {
                            fn();
                        });
                        $$_recalculate.delete(firstElement);
                    }
                    for (let key in $$_depVar.dependents) {
                        if (key == 'variables') {
                            for (let nm of $$_depVar.dependents[key]) {
                                if($$_done.has(nm)){
                                    continue;
                                }
                                if(nm == firstElement){
                                    $$_depVar.recalculate.forEach((fn, index) => {
                                        fn();
                                    });
                                } else {
                                    $$changes.add(nm);
                                    $$_recalculate.add(nm);
                                }
                            }
                            continue;
                        }
                        for (let fn of $$_depVar.dependents[key]) {
                            fn();
                        }
                    }
                    $$_done.add(firstElement);
                    // Remove the first element
                    $$changes.delete(firstElement);
                }

                $$_updating = false;
            },
            destroy(TARGET) {
                ${analysis.code.destroy.join(';\n')};
            },
            capture_state(){
                return { ${[...analysis.declared_variables, ...analysis.undeclared_variables].join(",")} };
            }
        }
        return $$_lifecycle;
    }`
}

function generate4React(scripts, styles, analysis) {

}

function generate4Vue(scripts, styles, analysis) {

}

function extractor_sfc_walker(ast, scripts, exthtml, styles, level) {
    level = level || 1
    let output = []
    for (let i = 0; i < ast.length; i++) {
        let node = ast[i];
        if (node.section != 'ExtHTMLDocument') {
            continue
        }

        if (node.type == 'SCRIPT_TAG') {
            scripts.push(node)
        } else if (node.type == 'STYLE_TAG') {
            styles.push(node)
        } else if (node.children) {
            extractor_sfc_walker(node.children, scripts, exthtml, styles, level + 1)
            if (level == 1) {
                exthtml.push(node)
            }
            output.push(node)
        }
    }
    return output
}

function print_nodes(ast, indent = 0) {
    const indentStr = '\t'.repeat(indent);

    ast.forEach(node => {
        node_print = { ...node, children: undefined }
        console.log(indentStr + JSON.stringify(node_print, null, indentStr.replace("\t", "    ")))
        // If node has children, recursively print them with increased indent
        if (node.children && node.children.length > 0) {
            printNodes(node.children, indent + 1);
        }
    })
}