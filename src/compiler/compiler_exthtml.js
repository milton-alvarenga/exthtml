import fs from 'fs/promises';
import path from 'path';
import { parse } from "../parse/exthtml/parser_exthtml.js"
import { parseStyle, updateNames, ast2strCss } from "../parse/css/parser_css.js"
import { parseScript, parseCode, createSetReactiveNode, createCheckReactiveNode, parseEventDescription } from "../parse/js/parser_js.js"
import * as macro from "./directives/macro.js"
import * as drall from "./directives/drall.js"
import * as primitive from "./directives/primitive.js"
import * as pre_primitive from "./directives/pre_primitive.js"
import * as customAttr from "./attributes/custom.js"
import * as estreewalker from 'estree-walker';
import * as escodegen from 'escodegen';
import * as periscopic from 'periscopic';
import * as knownGlobals from './tools/knownGlobals.js';
import { locate } from 'locate-character';
import MagicString from 'magic-string';
import { inspect } from 'util';
import { getStructure } from './internals/analyze.js'
import * as codeUtils from './tools/codeUtils.js'
import {extHTMLElement} from './transform/extHTMLElement.js'

//import { style } from "../analyse/exthtml/directives/style";

let setup = {
    __VERSION__: '0.0.5',
    elem_counter: 1,
    dev_version: true,
}
setup.BANNER = `//Generated by ExtHTML v${setup.__VERSION__}`;

const USE_CURRENT_SCOPE = "USE_CURRENT_SCOPE";
const NEW_ISOLATED_SCOPE = "NEW_ISOLATED_SCOPE";
const BLOCK_SCOPE = "BLOCK_SCOPE";

export async function exthtmlCompileFile(filePath) {
    const source_code_content = await fs.readFile(filePath, 'utf8');
    try {
        return exthtmlCompile(source_code_content, filePath);
    } catch (err) {
        if (!Array.isArray(err.errors)) {
            err.errors = [err];
        }
        err.errors.unshift(new Error(`Error on file ${filePath}`))

        throw new AggregateError(err.errors)
    }
}


export function exthtmlCompile(source_code_content, filePath) {
    const ast = parse(source_code_content);

    let { scripts = [], exthtml = [], styles = [] } = extract_sfc_contents_parts(ast)
    //console.log(inspect(exthtml, { depth: null, colors: true, showHidden: true }));
    let parsedOutput = parseScriptsAndStylesTags(scripts, styles)
    scripts = parsedOutput[0]
    styles = parsedOutput[1]
    //console.log(inspect(scripts, { depth: null, colors: true, showHidden: true }));
    const analysis = analyse(exthtml, scripts, styles, filePath)
    //console.log(inspect(analysis, { depth: null, colors: true }))
    const generated_ctx = generateCtx(scripts, analysis)
    const generate_code = generate4Web(scripts, styles, analysis)
    return [scripts, exthtml, styles, generate_code, generated_ctx]
    return { ast: JSON.stringify(ast, null, 4) }
}

function extract_sfc_contents_parts(ast) {
    let scripts = []
    let exthtml = []
    let styles = []

    extractor_sfc_walker(ast, scripts, exthtml, styles)

    return { scripts, exthtml, styles }
}

function parseScriptsAndStylesTags(scripts, styles) {

    for (let x = 0; x < scripts.length; x++) {
        scripts[x].children = parseScript(scripts[x])
    }
    for (let x = 0; x < styles.length; x++) {
        styles[x].children = parseStyle(styles[x])
    }

    return [scripts, styles]
}

function analyse(exthtml, scripts, styles, filePath) {
    const result = getStructure()
    for (let x = 0; x < styles.length; x++) {
        if (styles[x].value) {
            result.cssTree = updateNames(styles[x],result.cssTree.classNames,result.cssTree.idNames,result.cssTree.typeSelector)

            if (filePath) {
                if (x > 0) {
                    continue
                }
                let baseName = filePath + '.css'; 
                result.code.internal_import.add('addCssLinkOnHead')
                result.code.internal_import.add('removeCssLinkFromHead')
                result.code.create.push(` $$_addCssLinkOnHead('/${baseName}')`)
                result.code.destroy.push(` $$_removeCssLinkFromHead('/${baseName}')`)
                result.code.imports.push(`import 'virtual:${baseName}'`)
            } else {
                result.code.internal_import.add("el")
                result.code.internal_import.add("setAttr")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")

                let varname = '$$style_1'
                result.code.elems.push(varname)
                result.code.create.push(`${varname} = $$_el('style')`)
                result.code.create.push(` $$_setAttr(${variableName}, 'textContent', '${ast2strCss(styles[x].children)}'`)
                result.code.mount.push(` $$_append($$_TARGET,${variableName})`)
                result.code.destroy.push(` $$_detach(${variableName})`)
            }
        }
    }

    const reactiveDeclarations = []
    const toRemove = new Set()

    for (let x = 0; x < scripts.length; x++) {
        if (scripts[x].attrs.some(attr => attr.name == 'context' && attr.value === 'module')) {
            result.code.shared_state.push(escodegen.generate(scripts[x].children))
            continue
        }

        script_pre_analyse(scripts[x], result)
        const { scope: rootScope, map, globals } = periscopic.analyze(scripts[x].children)
        result.declared_variables = new Set(rootScope.declarations.keys())
        result.undeclared_variables = Array.from(globals.keys()).filter(v => !(knownGlobals.functions.has(v) || knownGlobals.objects.has(v)));

        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (parent !== null) {
                    this.skip();
                }

                if (node.type === 'FunctionDeclaration') {
                    result.functions.add(node.id.name)
                } else if (
                    node.type === 'VariableDeclaration'
                    &&
                    node.declarations
                ) {
                    node.declarations.forEach(decl => {
                        if (
                            decl
                            &&
                            decl.init
                            &&
                            (
                                decl.init.type === 'FunctionExpression'
                                ||
                                decl.init.type === 'ArrowFunctionExpression'
                            )
                        ) {
                            result.functions.add(decl.id.name);
                        }
                    })
                }
            }
        });



        result.reactiveDeclarations = reactiveDeclarations

        estreewalker.walk(scripts[x].children, {
            enter(node, parent) {
                if (
                    node.type === 'VariableDeclaration'
                    &&
                    parent.type === 'Program'
                ) {
                    node.declarations.forEach(decl => {
                        if (result.functions.has(decl.id.name)) {
                            return;
                        }

                        let depVar = result.dependencyTree.get(decl.id.name);
                        depVar.declarationType = node.kind;

                        let has_dependency = false;
                        if (decl.init) {
                            let is_object = decl.init.type == 'ObjectExpression';
                            estreewalker.walk(decl.init, {
                                enter(innerNode, parent) {
                                    if (innerNode.type === 'Identifier') {
                                        if (is_object && parent.key == innerNode) {
                                            return
                                        }
                                        has_dependency = true
                                        let _depVar = result.dependencyTree.get(innerNode.name);
                                        _depVar.dependents.variables.add(decl.id.name);
                                        depVar.dependsOn.variables.add(innerNode.name);
                                    }
                                }
                            });
                        }

                        if (node.kind !== 'const' && has_dependency) {
                            const assignmentAst = {
                                type: 'ExpressionStatement',
                                expression: {
                                    type: 'AssignmentExpression',
                                    operator: '=',
                                    left: decl.id,
                                    right: decl.init || { type: 'Identifier', name: 'undefined' }
                                }
                            };

                            const assignmentCode = escodegen.generate(assignmentAst);

                            let depVar = result.dependencyTree.get(decl.id.name);
                            depVar.recalculate.push(`() => { ${assignmentCode} }`);
                        }

                        const setReactiveNode = createSetReactiveNode(decl.id.name);

                        const index = parent.body.indexOf(node);

                        if (index !== -1) {
                            parent.body.splice(index + 1, 0, setReactiveNode);
                        }
                    });
                }
            }
        });

        let currentScope = rootScope
        let closestBodyParentStack = [];
        let parentStack = [];
        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                parentStack.push(node);
                if (node.body && Array.isArray(node.body)) {
                    closestBodyParentStack.push(node);
                }
                if (map.has(node)) currentScope = map.get(node);

                if (
                    node.type === 'UpdateExpression'
                    ||
                    node.type === 'AssignmentExpression'
                ) {
                    const names = periscopic.extract_names(
                        node.type === 'UpdateExpression' ? node.argument : node.left
                    );
                    for (const name of names) {
                        if (
                            currentScope.find_owner(name) === rootScope
                        ) {
                            result.willChange.add(name);

                            const checkReactiveNode = createCheckReactiveNode(name);

                            const enclosingStmt = parentStack
                                .slice() 
                                .reverse()
                                .find(n =>
                                    n && n.type && n.type.endsWith('Statement') &&
                                    closestBodyParentStack[closestBodyParentStack.length - 1]?.body?.includes(n)
                                );

                            const closestParent = closestBodyParentStack[closestBodyParentStack.length - 1];

                            if (enclosingStmt && closestParent) {
                                const body = closestParent.body;
                                const index = body.indexOf(enclosingStmt);
                                if (index !== -1) {
                                    body.splice(index + 1, 0, checkReactiveNode);
                                }
                            }
                        }
                    }
                }

                if (
                    node.type === "AssignmentExpression"
                    &&
                    node.left.type === "MemberExpression"
                ) {
                    let name = null;
                    if (node.left.computed) {
                        name = node.left.object.name
                    } else {
                        name = node.left.object.name
                    }

                    if (
                        name
                        &&
                        (
                            currentScope.find_owner(name) === rootScope
                        )
                    ) {
                        result.willChange.add(name);
                        let depVar = result.dependencyTree.get(name);
                        const assignmentCode = escodegen.generate(node);
                        depVar.recalculate.push(`() => { ${assignmentCode} }`);



                        estreewalker.walk(node.right, {
                            enter(node) {
                                if (
                                    node.type === 'Identifier'
                                    &&
                                    (
                                        currentScope.find_owner(node.name) === rootScope
                                        ||
                                        globals.has(node.name)
                                    )

                                ) {
                                    depVar.dependsOn.variables.add(node.name);
                                    let _depVar = result.dependencyTree.get(node.name);
                                    _depVar.dependents.variables.add(name);
                                }
                            }
                        });
                    }
                }
            },
            leave(node) {
                if (map.has(node)) currentScope = currentScope.parent;

                if (node.body && Array.isArray(node.body)) {
                    closestBodyParentStack.pop();
                }
            },
        });
        script_pos_analyse(scripts[x], result)
    }

    exthtml.forEach((node, pos) => exthtml_pre_analyse(node, result, ' $$__TARGET', exthtml, pos))
    exthtml.forEach(node => traverseExthtml(node, result, ' $$__TARGET'))

    result.dependencyTree.css.idNames = result.cssTree.idNames
    result.code.dependencyTree.push(...result.dependencyTree.compile())
    if(result.code.internal_import.has('setAttr')){
        result.code.internal_import.add('setDepTree')
    }
    return result
}

function script_pre_analyse(script, result) {
    moveImportToTheTop(script, result)
}

function moveImportToTheTop(script, result) {
    estreewalker.walk(script, {
        enter(node, parent, prop, index) {
            if (node.type === 'ImportDeclaration') {
                const importCode = escodegen.generate(node, { format: { semicolons: false } });
                result.code.imports.push(importCode);
                this.remove();
            }
        }
    });
}

function removeDuplicateCheckReactiveDeep(node, lastFound) {
    if (!node || typeof node !== 'object') return;

    lastFound = lastFound || "";
    for (const key in node) {
        if (Array.isArray(node[key])) {
            if (key === 'body' || key === 'consequent' || key === 'alternate' || key === 'block' || key === 'handlers') {
                node[key] = node[key].filter(child => {
                    if (
                        child.type === 'ExpressionStatement'
                        &&
                        child.expression.type === 'CallExpression'
                        &&
                        child.expression.callee.type === 'Identifier'
                        &&
                        child.expression.callee.name === ' $$__checkReactive'
                        &&
                        child.expression.arguments.length === 4
                        &&
                        child.expression.arguments[0].type === 'Literal'
                    ) {
                        const varName = child.expression.arguments[0].value;
                        if (lastFound == varName) {
                            return false;
                        } else {
                            lastFound = varName
                            return true;
                        }
                    }
                    lastFound = ""
                    return true;
                });
            }
            node[key].forEach(child => removeDuplicateCheckReactiveDeep(child, lastFound));
        } else if (node[key] && typeof node[key] === 'object') {
            removeDuplicateCheckReactiveDeep(node[key], lastFound);
        }
    }
}

function script_pos_analyse(script, result) {
    removeDuplicateCheckReactiveDeep(script.children)
}

function exthtml_pre_analyse(exthtml, result, parent_nm, parent_elem, parent_pos){
    switch (exthtml.type) {
        case 'NEW_LINE':
        case 'SINGLE_LINE_COMMENT':
        case 'MULTIPLE_LINE_COMMENT':
        case 'COMMENT_TEXT':
        case 'SCRIPT_TAG':
        case 'STYLE_TAG':
        case 'DYNAMIC_TEXT_NODE':
        case 'TEXT_NODE':
            return
        case 'TEXTAREA_TAG':
        case 'TITLE_TAG':
        case 'PLAINTEXT_TAG':
        case 'HTML_NESTED_TAG':
        case 'SELF_CLOSE_TAG':
        case 'COMPONENT':
            break
        default:
            throw Error(`${exthtml_pre_analyse.name} Error on unexpected type equal ${exthtml[0].type} and value ${exthtml[0].value} at line ${exthtml[0].location.line}`)
    }

    let variableName = getVariableName(exthtml)
    let len = exthtml.dynamic_attrs.length
    for(let i = len - 1; i >= 0; i--) {
        let dynamicAttr = exthtml.dynamic_attrs[i]
        pre_traverseExthtmlAttr(dynamicAttr, "DYNAMIC", result, variableName, exthtml, parent_nm, parent_elem, parent_pos)
    }
    exthtml.children.forEach((node,index) => exthtml_pre_analyse(node, result, variableName, exthtml.children, index))
}

function exthtml_pos_analyse(exthtml, result, parent_nm, parent_node, parent_elem, parent_pos){

}

function iterateExthtml(exthtml, result, parent_nm) {
    try {
        switch (exthtml.type) {
            case 'NEW_LINE':
            case 'SINGLE_LINE_COMMENT':
            case 'MULTIPLE_LINE_COMMENT':
            case 'COMMENT_TEXT':
            case 'SCRIPT_TAG':
            case 'STYLE_TAG':
                return
        }
        let extHTMLEL = new extHTMLElement(setup,exthtml,result,parent_nm)
        extHTMLEL.main()
        extHTMLEL.mount()
    } catch(e){

    }
}


function getVariableName(exthtml){
    switch (exthtml.type) {
        case 'NEW_LINE':
        case 'SINGLE_LINE_COMMENT':
        case 'MULTIPLE_LINE_COMMENT':
        case 'COMMENT_TEXT':
        case 'SCRIPT_TAG':
        case 'STYLE_TAG':
            return ''
        case 'DYNAMIC_TEXT_NODE':
            return `$$dyn_txt_${setup.elem_counter++}`
        case 'TEXT_NODE':
            return `$$txt_${setup.elem_counter++}`
        case 'TEXTAREA_TAG':
            return `$$textarea_${setup.elem_counter++}`
        case 'TITLE_TAG':
            return `$$textarea_${setup.elem_counter++}`
        case 'PLAINTEXT_TAG':
            return `$$plaintext_${setup.elem_counter++}`
        case 'HTML_NESTED_TAG':
        case 'SELF_CLOSE_TAG':
            return `$$${exthtml.value.toLowerCase()}_${setup.elem_counter++}`
        case 'COMPONENT':
            return `$$${exthtml.value}_${setup.elem_counter++}`
        case 'VirtualIF':
            return `$$if_${setup.elem_counter++}`
        case 'VirtualFOR':
            return `$$for_${setup.elem_counter++}`
        default:
            throw Error(`${traverseExthtml.name} Error on unexpected type equal ${exthtml.type} and value ${exthtml.value} at line ${exthtml.location.line}`)
    }
}

function traverseExthtml(exthtml, result, parent_nm, anchor_nm = null, root_elements_set = null) {
    let variableName = ''
    let variableNameAnchor = ''
    let reactiveFnName = ''
    let usedVars = []
    try {
        switch (exthtml.type) {
            case 'NEW_LINE':
            case 'SINGLE_LINE_COMMENT':
            case 'MULTIPLE_LINE_COMMENT':
            case 'COMMENT_TEXT':
            case 'SCRIPT_TAG':
            case 'STYLE_TAG':
                return
            case 'DYNAMIC_TEXT_NODE':
                result.code.internal_import.add("text")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                variableName = getVariableName(exthtml)
                if (root_elements_set) root_elements_set.add(variableName);
                reactiveFnName = `${variableName}__textContent`
                result.code.elems.push(variableName)
                if (setup.dev_version) result.code.create.push(`/* DYNAMIC_TEXT_NODE: ${exthtml.value} */`);
                result.code.create.push(`${variableName} = $$_text(${codeUtils.escapeNewLine(exthtml.value)})`)
                usedVars = extract_relevant_js_parts_evaluated_to_string(exthtml.value, result)
                for (const v of usedVars) {
                    let depVar = result.dependencyTree.get(v)
                    depVar.dependents.texts.add(reactiveFnName)
                }
                result.code.reactives.push(`function ${reactiveFnName}(){${variableName}.textContent = ${exthtml.value}}
`)
                result.code.mount.push(` $$_append(${parent_nm},${variableName},${anchor_nm})`)
                result.code.destroy.push(` $$_detach(${variableName})`)
                return

            case 'TEXT_NODE':
                result.code.internal_import.add("text")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                variableName = getVariableName(exthtml)
                if (root_elements_set) root_elements_set.add(variableName);
                result.code.elems.push(variableName)
                if (setup.dev_version) result.code.create.push(`/* TEXT_NODE: ${variableName} */`);
                result.code.create.push(`${variableName} = $$_text('${codeUtils.escapeNewLine(exthtml.value)}')`)
                if (setup.dev_version) result.code.mount.push(`/* TEXT_NODE: ${variableName} */`);
                result.code.mount.push(` $$_append(${parent_nm},${variableName},${anchor_nm})`)
                if (setup.dev_version) result.code.destroy.push(`/* TEXT_NODE: ${variableName} */`);
                result.code.destroy.push(` $$_detach(${variableName})`)
                return

            case 'TEXTAREA_TAG':
                variableName = getVariableName(exthtml)
                break
            case 'TITLE_TAG':
                variableName = getVariableName(exthtml)
                break
            case 'PLAINTEXT_TAG':
                variableName = getVariableName(exthtml)
                break
            case 'HTML_NESTED_TAG':
            case 'SELF_CLOSE_TAG':
                variableName = getVariableName(exthtml)
                break
            case 'COMPONENT':
                variableName = getVariableName(exthtml);
                if (root_elements_set) root_elements_set.add(variableName);
                result.code.internal_import.add("el")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                result.code.internal_import.add("comment")

                const componentName = exthtml.value;
                const componentImportName = componentName;
                result.code.elems.push(variableName);

                if (setup.dev_version) result.code.create.push(`/* COMPONENT: ${componentName} */`);
                result.code.create.push(`${variableName} = ${componentImportName}();`);

                variableNameAnchor = `${variableName}__anchor`
                result.code.elems.push(variableNameAnchor)
                if (setup.dev_version) result.code.create.push(`/* VirtualComponent: ${variableName} */`);
                result.code.create.push(`${variableNameAnchor} = $$_comment('${variableName}')`)
                if (setup.dev_version) result.code.mount.push(`/* ${exthtml.type}: ${exthtml.value} */`);
                result.code.mount.push(` $$_append(${parent_nm}, ${variableNameAnchor}, ${anchor_nm});`);
                result.code.mount.push(`${variableName}.mount(${variableNameAnchor});`);

                if (setup.dev_version) result.code.destroy.push(`/* COMPONENT: ${componentName} */`);
                result.code.destroy.push(`${variableName}.destroy();`);
                result.code.destroy.push(` $$_detach(${variableNameAnchor});`);

                return;

            case 'VirtualIF':
                variableName = getVariableName(exthtml)
                if (root_elements_set) root_elements_set.add(variableName);
                result.code.internal_import.add("el")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                result.code.internal_import.add("comment")

                reactiveFnName = `${variableName}__ifBlock`
                variableNameAnchor = `${variableName}__anchor`
                result.code.elems.push(variableNameAnchor)
                if (setup.dev_version) result.code.create.push(`/* VirtualIF: ${variableName} */`);
                result.code.create.push(`${variableNameAnchor} = $$_comment('${variableName}')`)
                if (setup.dev_version) result.code.mount.push(`/* ${exthtml.type}: ${exthtml.value} */`);
                result.code.mount.push(` $$_append(${parent_nm},${variableNameAnchor},${anchor_nm})`)


                usedVars = extract_relevant_js_parts_evaluated_to_string(exthtml.value, result)
                for (const v of usedVars) {
                    let depVar = result.dependencyTree.get(v)
                    depVar.dependents.directives.add(reactiveFnName)
                }

                let result_if_block = {
                    ...result,
                    code: {
                        ...result.code,
                        create: [],
                        mount: [],
                        update: [],
                        destroy: []
                    }
                };

                exthtml.children.forEach(node => traverseExthtml(node, result_if_block, parent_nm, variableNameAnchor, null))

                result.code.reactives.push(`
                function ${reactiveFnName}_create(){
                    ${result_if_block.code.create.join(";\n")};
                }
                function ${reactiveFnName}_mount(){
                    ${result_if_block.code.mount.join(";\n")};
                }
                function ${reactiveFnName}_destroy(){
                    ${result_if_block.code.destroy.join(";\n")};
                }
                function ${reactiveFnName}(){
                    if(${exthtml.value}){
                        ${reactiveFnName}_create();
                        ${reactiveFnName}_mount();
                    } else {
                        ${reactiveFnName}_destroy();
                    }
                }`)

                if (setup.dev_version) result.code.mount.push(`/* ${exthtml.type}: ${exthtml.value} */`);
                result.code.mount.push(`${reactiveFnName}()`)
                if (setup.dev_version) result.code.destroy.push(`/* ${exthtml.type}: ${exthtml.value} */`);
                result.code.destroy.push(` $$_detach(${variableNameAnchor})`)


                return;
            case 'VirtualFOR':
                variableName = getVariableName(exthtml);
                if (root_elements_set) root_elements_set.add(variableName);
                result.code.internal_import.add("keyed");
                result.code.internal_import.add("comment");
                result.code.internal_import.add("detach");

                const forExpression = JSON.parse(exthtml.value);
                const forExpressionVar = forExpression.collection;
                const itemVar = forExpression.item;
                const indexVar = forExpression.index;
                const keyFn = indexVar ? `(item, i) => i` : `(item) => item`;

                reactiveFnName = `${variableName}__forBlock_update`;
                usedVars = extract_relevant_js_parts_evaluated_to_string(forExpressionVar, result);
                for (const v of usedVars) {
                    let depVar = result.dependencyTree.get(v);
                    depVar.dependents.directives.add(reactiveFnName);
                }

                const for_block_result = {
                    ...result,
                    code: {
                        ...result.code,
                        create: [], mount: [], update: [], destroy: [], elems: [], root_elements: new Set(),
                    }
                };
                
                exthtml.children.forEach((node) => traverseExthtml(node, for_block_result, ' $$__for_fragment', null, for_block_result.code.root_elements));
                
                const block_creation_code = `
                (item, key) => {
                    let ${itemVar} = item;
                    ${indexVar ? `let ${indexVar} = key;` : ''}
                    let ${Array.from(for_block_result.code.elems).join(',')};

                    ${for_block_result.code.create.join(";\n")};
                    
                    const root_nodes = [${Array.from(for_block_result.code.root_elements).join(',')}];

                    const block = {
                        key,
                        update(new_item, new_index) {
                            ${itemVar} = new_item;
                            ${indexVar ? `${indexVar} = new_index;` : ''}
                        },
                        mount(parent, anchor) {
                            root_nodes.forEach(node => parent.insertBefore(node, anchor));
                        },
                        first_node() {
                            return root_nodes[0];
                        },
                        destroy() {
                            root_nodes.forEach(node => $$_detach(node));
                        }
                    };
                    return block;
                }
                `;

                variableNameAnchor = `${variableName}__anchor`;
                result.code.elems.push(variableNameAnchor);
                if (setup.dev_version) result.code.create.push(`/* VirtualFOR: ${variableName} */`);
                result.code.create.push(`${variableNameAnchor} = $$_comment('keyed-for-anchor');`);
                result.code.mount.push(` $$_append(${parent_nm}, ${variableNameAnchor}, ${anchor_nm});`);

                result.code.reactives.push(`
                    const ${reactiveFnName}_updater = $$_keyed(
                        ${parent_nm},
                        () => ${forExpressionVar},
                        ${keyFn},
                        ${block_creation_code}
                    );
                `);
                
                result.code.update.push(`${reactiveFnName}_updater();`);
                return;

            default:
                throw Error(`${traverseExthtml.name} Error on unexpected type equal ${exthtml.type} and value ${exthtml.value} at line ${exthtml.location.line}`)
        }

        if (root_elements_set) root_elements_set.add(variableName);

        result.code.internal_import.add("el")
        result.code.internal_import.add("append")
        result.code.internal_import.add("detach")
        result.code.elems.push(variableName)

        if (setup.dev_version) result.code.create.push(`/* ${exthtml.type}: ${exthtml.value} */`);
        result.code.create.push(`${variableName} = $$_el('${exthtml.value.toLowerCase()}')`)

        if (
            result.cssTree.typeSelector.hasOwnProperty(exthtml.value.toLowerCase())
        ){
            if (setup.dev_version) result.code.create.push(`/* ${exthtml.type}: CSS type selector */`);
            result.code.create.push(`${variableName}.classList.add('${result.cssTree.typeSelector[exthtml.value.toLowerCase()]}')`)
        }
        
        if(result.cssTree.typeSelector.hasOwnProperty('*')){
            if (setup.dev_version) result.code.create.push(`/* ${exthtml.type}: Universal css selector */`);
            result.code.create.push(`${variableName}.classList.add('${result.cssTree.typeSelector['*']}')`)
        }

        exthtml.attrs.forEach(attr => traverseExthtmlAttr(attr, "STATIC", result, variableName, exthtml, parent_nm))
        exthtml.dynamic_attrs.forEach(dynamicAttr => traverseExthtmlAttr(dynamicAttr, "DYNAMIC", result, variableName, exthtml, parent_nm))
        exthtml.event_attrs.forEach(eventAttr => traverseExthtmlEventAttr(eventAttr, "DYNAMIC", result, variableName, parent_nm))
        exthtml.children.forEach(node => traverseExthtml(node, result, variableName, null, null))

        if (setup.dev_version) result.code.mount.push(`/* ${exthtml.type}: ${exthtml.value} */`);
        result.code.mount.push(` $$_append(${parent_nm},${variableName},${anchor_nm})`)
        if (setup.dev_version) result.code.destroy.push(`/* ${exthtml.type}: ${exthtml.value} */`);
        result.code.destroy.push(` $$_detach(${variableName})`)
    } catch (err) {
        let errors = [err, new Error(`${traverseExthtml.name} Error on ${exthtml.type}.${exthtml.value} at line ${exthtml.location.start.line}`)]
        console.log(errors);
        throw new AggregateError(errors)
    }
}

function pre_traverseExthtmlAttr(attr, mode, result, variableName, node, parent_nm, parent_elem, parent_pos) {
    switch (attr.category) {
        case "lang_directive":
            pre_htmlLangDirective(attr, mode, result, variableName, node, parent_nm, parent_elem, parent_pos)
            break
    }
}

function traverseExthtmlAttr(attr, mode, result, variableName, node, parent_nm) {
    let aValidMode = ['DYNAMIC', 'STATIC']
    if (!aValidMode.includes(mode)) {
        throw new Error(`Invalid mode: ${mode}. Expected one of: ${aValidMode.join(', ')}`);
    }

    switch (attr.category) {
        case "html_global_boolean_attribute":
        case "html_boolean_attribute":
            htmlBooleanAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_data_attribute":
            htmlDataAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_global_non_boolean_attribute":
        case "html_attribute":
            htmlRegularAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_media_readonly":
        case "html_video_readonly":
            htmlReadOnlyAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "class_directive":
            htmlClassDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "lang_directive":
            htmlLangDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "custom_attribute":
            htmlCustomAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "drall_directive":
            htmlDrallDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "macro_directive":
            htmlMacroDirective(attr, mode, result, variableName, node, parent_nm)
            break
        default:
            throw Error(`${traverseExthtmlAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is of category ${attr.category} not recognized`)
    }
}

function checkMode(mode) {
    let aValidMode = ['DYNAMIC', 'STATIC']

    if (!aValidMode.includes(mode)) {
        throw new Error(`Invalid mode: ${mode}. Expected one of: ${aValidMode.join(', ')}`);
    }
}

function traverseExthtmlEventAttr(eventAttr, mode, result, variableName, parent_nm) {
    checkMode(mode)

    if (mode != "DYNAMIC") {
        throw new Error(`Invalid mode: ${mode} for extHTML event Attribute.}`);
    }


    let modifierChecks = '';
    if (eventAttr.keyboard_modifiers_keys && eventAttr.keyboard_modifiers_keys.length > 0) {
        const mods = eventAttr.keyboard_modifiers_keys.map(key => `event.${key}Key`).join(' && ');
        modifierChecks = mods ? `if (!(${mods})) return;` : '';
    }

    let mouseKeyCheck = '';
    if (eventAttr.mouse_keys) {
        const mouseButtonMap = {
            left: 0,
            middle: 1,
            right: 2
        };
        const btnCode = mouseButtonMap[eventAttr.mouse_keys.toLowerCase()];
        if (btnCode !== undefined) {
            mouseKeyCheck = `if (event.button !== ${btnCode}) return;`;
        }
    }

    let reactiveFnName = `${variableName}__handlerCode`


    let descriptors = parseEventDescription(eventAttr.value)

    let handlerCode = ''
    if (['functionName', 'functionCall'].indexOf(descriptors.type) > -1) {
        if (!result.functions.has(descriptors.name)) {
            throw Error(`${traverseExthtmlEventAttr.name} function: Invalid ${descriptors.type.toLowerCase()} attribute on ${attr.name} and its value as ${attr.value}`)
        }

        if (descriptors.type == 'functionName') {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    (${eventAttr.value}) && (${eventAttr.value})(event)
                }
            `.trim();
        } else {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    (${descriptors.name}) && (${eventAttr.value})
                }
            `.trim();
        }
    } else if (['methodCall'].indexOf(descriptors.type) > -1) {
        if(result.declared_variables.has(descriptors.variable) || knownGlobals.objects(descriptors.variable)){
            let reactive = [descriptors.variable].filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    (${descriptors.variable}) && (${eventAttr.value})
                    ${reactive}
                }
            `.trim();
        } else {
            throw Error(`${traverseExthtmlEventAttr.name} function: Invalid ${descriptors.type.toLowerCase()} attribute on ${attr.name} and its value as ${attr.value}`)
        }
    } else if (['methodCallWithParams'].indexOf(descriptors.type) > -1) {
        if(result.declared_variables.has(descriptors.variable) || (knownGlobals.objects(descriptors.variable))){
            let reactive = [descriptors.variable].filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    (${descriptors.variable}) && (${descriptors.variable}${descriptors.methodName ? ".\n"+descriptors.methodName : ""}(${descriptors.parameters.join(',')}))
                    ${reactive}
                }
            `.trim();
        } else {
            throw Error(`${traverseExthtmlEventAttr.name} function: Invalid ${descriptors.type.toLowerCase()} attribute on ${attr.name} and its value as ${attr.value}`)
        }
    } else if (descriptors.type == 'functionCallWithParams') {
        if (!result.functions.has(descriptors.name)) {
            throw Error(`${traverseExthtmlEventAttr.name} function: Invalid ${descriptors.type.toLowerCase()} attribute on ${attr.name} and its value as ${attr.value}`)
        }
        handlerCode = `
            function ${reactiveFnName}(event) {
                ${modifierChecks}
                ${mouseKeyCheck}
                (${descriptors.name}) && (${descriptors.name})(${descriptors.parameters.join(',')})
            }
        `.trim();
    } else if (descriptors.type == 'assignment') {
        let reactive = [descriptors.variableChanged].filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
        handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    ${eventAttr.value}
                    ${reactive}
                }
            `.trim();

    } else if (descriptors.type == 'arrowFunction') {
        let ast = parseCode(descriptors.rawBody)
        const { scope: rootScope, map, globals } = periscopic.analyze(ast)
        let reactive = Array.from(globals.keys()).filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
        if (descriptors.parameters.length) {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    let $$_arrowfn = (${descriptors.parameters.join(',')})=>${descriptors.rawBody};
                    $$_arrowfn(${descriptors.parameters.join(',')});
                    ${reactive}
                }
            `.trim();
        } else {
            handlerCode = `
                function ${reactiveFnName}(event) {
                    ${modifierChecks}
                    ${mouseKeyCheck}
                    let $$_arrowfn = (event)=>${descriptors.rawBody};
                    $$_arrowfn(event);
                    ${reactive}
                }
            `.trim();
        }
    } else if (descriptors.type == 'updateExpression') {
        let reactive = [descriptors.variableChanged].filter((nm) => result.declared_variables.has(nm)).map(nm => escodegen.generate(createCheckReactiveNode(nm))).join(';\n');
        handlerCode = `
            function ${reactiveFnName}(event) {
                ${modifierChecks}
                ${mouseKeyCheck}
                ${eventAttr.value}
                ${reactive}
            }
        `.trim();
    } else {
        handlerCode = `
            function ${reactiveFnName}(event) {
                ${modifierChecks}
                ${mouseKeyCheck}
                (${eventAttr.value}) && (${eventAttr.value})(event)
            }
        `.trim();
    }

    result.code.reactives.push(`${handlerCode.trim()}\n`)
    result.code.mount.push(`${variableName}.addEventListener('${eventAttr.name}', ${reactiveFnName})`);
    result.code.destroy.push(`${variableName}.removeEventListener('${eventAttr.name}', ${reactiveFnName})`);
}


function htmlBooleanAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    result.code.internal_import.add("setAttr")
    result.code.internal_import.add("rmAttr")

    if (mode == "STATIC") {
        result.code.create.push(`('${attr.value}') ? $$_setAttr(${variableName}, '${attr.name}', '${attr.value}') : $$_rmAttr(${variableName}, '${attr.name}')`)
    } else {
        let reactiveFnName = `${variableName}__${attr.name}`
        let usedVars = extract_relevant_js_parts_evaluated_to_boolean(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
        }
        result.code.reactives.push(`function ${reactiveFnName}(){
            (${attr.value}) ? $$_setAttr(${variableName}, '${attr.name}', ${!!attr.value} ? "" : false) : $$_rmAttr(${variableName}, '${attr.name}')
        }`)
        result.code.create.push(`${reactiveFnName}()`)
    }
}

function htmlDataAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    const dataKey = attr.name.slice(5) 

    if (mode === "STATIC") {
        result.code.create.push(`('${attr.value}') ? ${variableName}.dataset['${dataKey}'] = '${attr.value}' : delete ${variableName}.dataset['${dataKey}']`)
    } else {
        result.code.internal_import.add("setAttr")
        result.code.internal_import.add("rmAttr")

        let reactiveFnName = `${variableName}__dataset`

        let usedVars = extract_relevant_js_parts_evaluated_to_string(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
        }


        result.code.reactives.push(`function ${reactiveFnName}(){(${attr.value}) ? ${variableName}.dataset['${dataKey}'] = ${attr.value} : delete ${variableName}.dataset['${dataKey}']}`)
        result.code.create.push(`${reactiveFnName}()`)
    }
}

function htmlClassDirective(attr, mode, result, variableName, node, parent_nm) {
    if (mode != "DYNAMIC") {
        throw Error(`${htmlClassDirective.name} function: Invalid ${mode.toLowerCase()} attribute on class directive as it is only dynamic attribute`)
    }

    result.code.internal_import.add("rmAttr")

    let reactiveFnName = `${variableName}__${attr.name}`
    let usedVars = extract_relevant_js_parts_evaluated_to_boolean(attr.value, result)
    for (const v of usedVars) {
        let depVar = result.dependencyTree.get(v)
        depVar.dependents.directives.add(reactiveFnName)
    }

    let className = result.cssTree.classNames.hasOwnProperty(attr.name.trim()) ? result.cssTree.classNames[attr.name.trim()] : attr.name.trim()
    result.code.reactives.push(`function ${reactiveFnName}(){
        (!!(${attr.value})) ? ${variableName}.classList.add('${className}') : ${variableName}.classList.remove('${className}') && ${variableName}.classList.length === 0 && $$_rmAttr(${variableName}, 'class')
    }`)
    result.code.create.push(`${reactiveFnName}()`)
}

function htmlClassAttr(attr, mode, result, variableName, node, parent_nm) {
    if (mode === "DYNAMIC") {
        let operations = attr.value.split(",")

        operations.forEach(operation => {
            let [_class, expression] = operation.split(":").map(v => v.trim());
            if (!_class) {
                throw Error(`${htmlClassAttr.name} function: Invalid empty class attribute '${operation}'`)
            }
            result.code.internal_import.add("rmAttr")
            let reactiveFnName = `${variableName}__${_class}`
            let usedVars = extract_relevant_js_parts_evaluated_to_boolean(expression, result)

            for (const v of usedVars) {
                let depVar = result.dependencyTree.get(v)
                depVar.dependents.directives.add(reactiveFnName)
            }
            let className = result.cssTree.classNames.hasOwnProperty(_class.trim()) ? result.cssTree.classNames[_class.trim()] : _class.trim()
            result.code.reactives.push(`function ${reactiveFnName}(){
                (!!(${expression})) ? ${variableName}.classList.add('${className}') : ${variableName}.classList.length === 1 ? $$_rmAttr(${variableName}, 'class') : ${variableName}.classList.remove('${className}')
            }`)
            result.code.create.push(`${reactiveFnName}()`)

        });
    } else {
        result.code.create.push(`${variableName}.classList.add('${attr.value.split(" ").map(cls => `"${result.cssTree.className[cls.trim()]}"`).join(", ")}')`)
    }
}

function htmlRegularAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)
    if (attr.name === 'class') {
        htmlClassAttr(attr, mode, result, variableName, node, parent_nm)
        return
    }
    if (attr.name === 'style') {
        handleStyleAttr(attr, mode, result, variableName);
        return;
    }

    result.code.internal_import.add("setAttr")
    result.code.internal_import.add("rmAttr")

    if (mode == "STATIC") {
        result.code.create.push(`('${attr.value}') ? $$_setAttr(${variableName}, '${attr.name}', '${attr.value}') : $$_rmAttr(${variableName}, '${attr.name}')`)
    } else {
        let reactiveFnName = `${variableName}__${attr.name}`

        let usedVars = extract_relevant_js_parts_evaluated_to_string(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
        }

        result.code.reactives.push(`function ${reactiveFnName}(){
            let cursorPosition
            if ('${node.value}' == 'INPUT' && ${attr.value} && document.activeElement === ${variableName}) {
                cursorPosition = ${variableName}.selectionStart
            };
            (${attr.value}) ? $$_setAttr(${variableName}, '${attr.name}', ${attr.value}) : $$_rmAttr(${variableName}, '${attr.name}');
            if ('${node.value}' == 'INPUT' && ${attr.value} && document.activeElement === ${variableName}) {
                ${variableName}.setSelectionRange(cursorPosition, cursorPosition)
            };
        }`)

        result.code.create.push(`${reactiveFnName}()`)
    }
}

function htmlReadOnlyAttr(attr, mode, result, variableName, node, parent_nm) {
    throw Error(`${htmlReadOnlyAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is readonly attribute`)
}

function htmlCustomAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in customAttr.customAttributes)) {
        throw Error(`${htmlCustomAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is html custom attribute but the compiler could not found it on custom attribute list`)
    }

    customAttr.customAttributes[attr.name](attr, mode, result, variableName, parent_nm)

}

function pre_htmlLangDirective(attr, mode, result, variableName, node, parent_nm, parent_elem, parent_pos) {
    checkMode(mode)
    if (!(attr.name in primitive.directives)) {
        throw Error(`${pre_htmlLangDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    pre_primitive.directives[attr.name](attr, mode, result, variableName, node, parent_nm, parent_elem, parent_pos)
}

function htmlLangDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in primitive.directives)) {
        throw Error(`${htmlLangDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    primitive.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function htmlDrallDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in drall.directives)) {
        throw Error(`${htmlDrallDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    drall.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function htmlMacroDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in macro.directives)) {
        throw Error(`${htmlMacroDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    macro.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function handleStyleAttr(attr, mode, result, variableName) {
    if (mode === "STATIC") {
        result.code.create.push(`${variableName}.setAttribute('style', '${attr.value}')`);
    } else if (mode === "DYNAMIC") {
        const styleVar = attr.value;
        result.code.update.push(`
            (function() {
                const el = ${variableName};
                el.style.cssText = '';
                const styleVal = ${styleVar};
                if (typeof styleVal === 'string') {
                    styleVal.split(';').forEach(decl => {
                        const [key, val] = decl.split(':').map(s => s && s.trim());
                        if(key && val) el.style.setProperty(key, val);
                    });
                } else if (Array.isArray(styleVal)) {
                    styleVal.forEach(decl => {
                        const [key, val] = decl.split(':').map(s => s && s.trim());
                        if(key && val) el.style.setProperty(key, val);
                    });
                } else if (typeof styleVal === 'object' && styleVal !== null) {
                    Object.entries(styleVal).forEach(([key, val]) => {
                        if(val != null) el.style.setProperty(key, val);
                    });
                }
            })()
        `);
    }
}

export function extract_relevant_js_parts_evaluated_to_string(code, result) {

    let ast = parseCode(code)
    let usedVars = new Set()

    estreewalker.walk(ast.body, {
        enter(node) {
            if (node.type === 'Identifier' && node.name) {
                result.willUseInTemplate.add(node.name)
                if (result.declared_variables.has(node.name)) {
                    usedVars.add(node.name)
                }
            }
        }
    })

    return usedVars
}

function extract_relevant_js_parts_evaluated_to_boolean(code, result) {
    return extract_relevant_js_parts_evaluated_to_string(code, result)
}


function generateCtx(scripts, analysis) {
    return ''
    return `function ctx(){
        ${Array.from(analysis.undeclared_variables).map((v) => `let ${v};`).join("\n")}
        ${scripts.map(script => escodegen.generate(script.children))}

        return [${[...analysis.declared_variables, ...analysis.undeclared_variables].filter(x => x).join(",	")}]
    }
    `
}

function generate4Web(scripts, styles, analysis) {
    let dev_only_code = '';
    let dev_mount_code = '';
    if (setup.dev_version) {
        dev_only_code = `
    if (!window.$$getInternals) {
        window.$$getInternals = (element) => {
            const target = element || (typeof $0 !== 'undefined' ? $0 : null);
            if (!target) {
                console.log("No element selected. Please select an element in the inspector or pass one as an argument.");
                return;
            }
            let current = target;
            while(current) {
                if (current.__extHTML_internals__) {
                    return current.__extHTML_internals__;
                }
                current = current.parentElement;
            }
            console.log("No extHTML component found for the selected element.");
        };
    }
    `;
        dev_mount_code = `
        const internalVars = {
            $$_dependencyTree,
            $$_changes,
            $$_TARGET,
            $$_mounted,
            $$_updating,
            ${[...analysis.declared_variables, ...analysis.undeclared_variables].join(",	")}
        };
        if ($$_TARGET) {
            $$_TARGET.__extHTML_internals__ = internalVars;
        }
        `;
    }

    const dom_imports = Array.from(analysis.code.internal_import).filter(name => name !== 'keyed');
    const keyed_import = analysis.code.internal_import.has('keyed')
        ? `import { keyed as $$_keyed } from 'exthtml/src/runtime/keyed.js';`
        : '';

    return `${setup.BANNER}
    ${dev_only_code}
    ${keyed_import}
    ${dom_imports.length > 0
            ? `import {${dom_imports.map(name => `${name} as $$_${name}`).join(", ")}} from 'exthtml/src/runtime/dom.js';`
            : ""}
    import {setReactive as $$_setReactive, checkReactive as $$_checkReactive, update as $$_update} from 'exthtml/src/runtime/reactive2.js';
    import { DependencyTree as $$_DependencyTree } from 'exthtml/src/compiler/internals/variable.js';
    ${analysis.code.imports.join(";\n")};

    // Shared state at the module scope
    ${analysis.code.shared_state.join("\n")}

    export default function(){
        ${analysis.code.elems.length > 0 ? `let ${analysis.code.elems.join(',')};` : ''}

        let $$_TARGET = null
        let $$_dependencyTree = new $$_DependencyTree();
        let $$_depVar = null;
        let $$changes = new Set();
        let $$_mounted = false;
        let $$_updating = false;

        let $$_changes = function(nm){
            if(!$$_mounted) return;
            $$changes.add(nm)
            if(!$$_updating){
                $$_lifecycle.update();
            }
        }

        ${analysis.code.internal_import.has('setDepTree') ? ` $$_setDepTree($$_dependencyTree);` : ""}

        ${scripts.filter(script => !script.attrs.some(attr => attr.name === 'context' && attr.value === 'module')).map(script => escodegen.generate(script.children) + '\n').join('')}


        ${analysis.code.reactives.join('\n')}


        ${analysis.code.dependencyTree.join(';\n')};

        let $$_lifecycle = {
            create() {
                ${analysis.code.create.join(';\n')};
            },
            mount(TARGET) {
                $$_TARGET = TARGET
                this.create();
                ${analysis.code.mount.join(';\n')};
                ${dev_mount_code}
                $$_mounted = true;
            },
            update() {
                if(!$$_mounted) return;
                if($$_updating) return;
                $$_updating = true;
                ${analysis.code.update.join(';\n')}

                $$_update($$changes,$$_dependencyTree)

                $$_updating = false;
            },
            destroy() {
                ${analysis.code.destroy.join(';\n')};
            },
            capture_state(){
                return { ${[...analysis.declared_variables, ...analysis.undeclared_variables].join(",	")} };
            }
        }
        return $$_lifecycle;
    }`
}
function generate4React(scripts, styles, analysis) {

}

function generate4Vue(scripts, styles, analysis) {

}

//SFC => Single File Component
function extractor_sfc_walker(ast, scripts, exthtml, styles, level) {
    level = level || 1
    let output = []
    for (let i = 0; i < ast.length; i++) {
        let node = ast[i];
        if (node.section != 'ExtHTMLDocument') {
            continue
        }

        if (node.type == 'SCRIPT_TAG') {
            scripts.push(node)
        } else if (node.type == 'STYLE_TAG') {
            styles.push(node)
        } else if (node.children) {
            extractor_sfc_walker(node.children, scripts, exthtml, styles, level + 1)
            if (level == 1) {
                exthtml.push(node)
            }
            output.push(node)
        }
    }
    return output
}

function print_nodes(ast, indent = 0) {
    const indentStr = '\t'.repeat(indent);

    ast.forEach(node => {
        node_print = { ...node, children: undefined }
        console.log(indentStr + JSON.stringify(node_print, null, indentStr.replace("\t", "    ")))
        if (node.children && node.children.length > 0) {
            printNodes(node.children, indent + 1);
        }
    })
}
