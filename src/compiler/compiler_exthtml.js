import fs from 'fs/promises';
import path from 'path';
import { parse } from "../parse/exthtml/parser_exthtml.js"
import { parseStyle } from "../parse/css/parser_css.js"
import { parseScript, parseCode, createSetReactiveNode, createCheckReactiveNode } from "../parse/js/parser_js.js"
import * as macro from "./directives/macro.js"
import * as drall from "./directives/drall.js"
import * as customAttr from "./attributes/custom.js"
import * as estreewalker from 'estree-walker';
import * as escodegen from 'escodegen';
import * as periscopic from 'periscopic';
import * as knownGlobals from './tools/knownGlobals.js';
import { locate } from 'locate-character';
import MagicString from 'magic-string';
import * as acorn from 'acorn'
import { inspect } from 'util';
import { DependencyTree } from './internals/variable.js';
import * as codeUtils from './tools/codeUtils.js'

//import { style } from "../analyse/exthtml/directives/style";

let __VERSION__ = '0.0.2'
const BANNER = `//Generated by ExtHTML v${__VERSION__}`

let elem_counter = 1

export async function exthtmlCompileFile(filePath) {
    const source_code_content = await fs.readFile(filePath, 'utf8');
    try {
        return exthtmlCompile(source_code_content,filePath);
    } catch (err) {
        if (!Array.isArray(err.errors)) {
            err.errors = [err];
        }
        err.errors.unshift(new Error(`Error on file ${filePath}`))

        throw new AggregateError(err.errors)
    }
}


export function exthtmlCompile(source_code_content,filePath) {
    const ast = parse(source_code_content);

    let { scripts = [], exthtml = [], styles = [] } = extract_sfc_contents_parts(ast)
    //console.log(inspect(exthtml, { depth: null, colors: true, showHidden: true }));
    let parsedOutput = parseScriptsAndStylesTags(scripts, styles)
    scripts = parsedOutput[0]
    styles = parsedOutput[1]
    const analysis = analyse(exthtml, scripts, styles, filePath)
//console.log(inspect(analysis, { depth: null, colors: true }))
    const generated_ctx = generateCtx(scripts, analysis)
    const generate_code = generate4Web(scripts, styles, analysis)
    return [scripts, exthtml, styles, generate_code, generated_ctx]
    return { ast: JSON.stringify(ast, null, 4) }
}

function extract_sfc_contents_parts(ast) {
    let scripts = []
    let exthtml = []
    let styles = []

    extractor_sfc_walker(ast, scripts, exthtml, styles)

    return { scripts, exthtml, styles }
}

function parseScriptsAndStylesTags(scripts, styles) {

    for (let x = 0; x < scripts.length; x++) {
        scripts[x].children = parseScript(scripts[x])
    }
    for (let x = 0; x < styles.length; x++) {
        styles[x].children = parseStyle(styles[x])
    }

    return [scripts, styles]
}

//https://www.perplexity.ai/search/program-structure-program-bloc-5ZZ_Sz1qS3K.m2rsWCXETg
function analyse(exthtml, scripts, styles, filePath) {
/*
        let vars = {
            count: {
                v:[0],
                dependencies:{
                    variable:[],
                    components:[],
                    directives:[]
                },
                dependents:{
                    variable:[],
                    components:[],
                    directives:[]
                }
            }
        };

        let dirty_queue = [
            {
                target_var:
                generated_by:
            }
        ]
*/
    const result = {
        declared_variables: new Set(),
        declared_const: new Set(),
        undeclared_variables: new Set(),
        dependencyTree: new DependencyTree(),
        /*
        Function declarations using the function keyword (e.g., function changeOK() { ... })
        Function expressions (e.g., const fn = function() { ... })
        Arrow functions (e.g., const fn = () => { ... })
        */
        functions: new Set(),
        willChange: new Set(),
        willUseInTemplate: new Set(),
        reactiveDeclarations: {},
        code: {
            internal_import: new Set(),
            imports: [],
            shared_state: [],
            regular_state: [],
            dependencyTree: [],
            elems: [],
            reactives: [],
            create: [],
            mount: [],
            update: [],
            destroy: []
        }
    }

    for (let x = 0; x < styles.length; x++) {
        if ( styles[x].value ){
            if( filePath ){
                if( x > 0 ){
                    continue
                }
                let baseName = path.basename(filePath, path.extname(filePath)) // get name without extension
                baseName += '.css'; // add .css extension
                result.code.internal_import.add('addCssLinkOnHead')
                result.code.internal_import.add('removeCssLinkFromHead')
                result.code.create.push(`$$_addCssLinkOnHead('/${baseName}')`)
                result.code.destroy.push(`$$_removeCssLinkFromHead('/${baseName}')`)
                result.code.imports.push(`import 'virtual:${baseName}'`)
            } else {
                //Must to be inline css as we did not know the component path
                result.code.internal_import.add("el")
                result.code.internal_import.add("setAttr")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")

                let varname = '$$style_1'
                result.code.elems.push(varname)
                result.code.create.push(`${varname} = $$_el('style')`)
                result.code.create.push(`$$_setAttr(${variableName}, 'textContent', '${styles[x].value}'`)
                result.code.mount.push(`$$_append(TARGET,${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
            }
        }
    }

    const reactiveDeclarations = []
    const toRemove = new Set()

    for (let x = 0; x < scripts.length; x++) {
        script_pre_analyse(scripts[x], result)
        const { scope: rootScope, map, globals } = periscopic.analyze(scripts[x].children)
        result.declared_variables = new Set(rootScope.declarations.keys())
        result.undeclared_variables = Array.from(globals.keys()).filter(v => !knownGlobals.functions.has(v));
        //console.log(inspect(scripts[x].children.body, { depth: null, colors: true }));

        /*
        scripts[x].children.body.forEach((node, index) => {
            if (node.type === 'LabeledStatement' && node.label.name === '$') {
                toRemove.add(node);
                const body = node.body;
                const left = body.expression.left;
                const right = body.expression.right;
                const dependencies = [];

                estreewalker.walk(right, {
                    enter(node) {
                        if (node.type === 'Identifier') {
                            dependencies.push(node.name);
                        }
                    },
                });
                result.willChange.add(left.name);
                const reactiveDeclaration = {
                    assignees: [left.name],
                    dependencies: dependencies,
                    node: body,
                    index,
                };
                reactiveDeclarations.push(reactiveDeclaration);
            }
        });


        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (node.type === 'LabeledStatement' && node.label.name === '$') {
                    // Replace the labeled statement node in the parent's body with the inner statement
                    if (parent && Array.isArray(parent.body)) {
                        const index = parent.body.indexOf(node);
                        if (index !== -1) {
                            parent.body.splice(index, 1, node.body);
                            // Stop walking this replaced node to avoid confusion
                            this.skip();
                        }
                    } else if (parent && parent.type === 'Program') {
                        // If parent is Program, replace in its body array
                        const index = parent.body.indexOf(node);
                        if (index !== -1) {
                            parent.body.splice(index, 1, node.body);
                            this.skip();
                        }
                    }
                }
            }
        });

        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (node.type === 'LabeledStatement' && node.label.name === '$') {
                    if (parent && Array.isArray(parent)) {
                        const index = parent.indexOf(node);
                        if (index !== -1) {
                            // Assuming node.body is an ExpressionStatement or similar
                            // Extract expression from node.body
                            let initExpression = null;
                            if (node.body.type === 'ExpressionStatement') {
                                initExpression = node.body.expression;
                            } else if (node.body.type === 'Literal' || node.body.type.endsWith('Expression')) {
                                initExpression = node.body;
                            } else {
                                // If node.body is a block or other statement, you need to handle differently
                                // For now, skip or throw error
                                this.skip();
                                return;
                            }

                            // Create a VariableDeclaration node
                            const varDecl = {
                                type: 'VariableDeclaration',
                                kind: 'let',
                                declarations: [{
                                    type: 'VariableDeclarator',
                                    id: { type: 'Identifier', name: 'x' }, // You can change 'x' to any variable name you want
                                    init: initExpression,
                                }]
                            };
console.log(inspect(parent, { depth: null, colors: true }));
                            // Replace the labeled statement with the new let declaration
                            parent.splice(index, 1, varDecl);
console.log("------------")
console.log(inspect(parent, { depth: null, colors: true }));
                            this.skip();
                        }
                    }
                }
            }
        });
*/




        //scripts[x].children.body = scripts[x].children.body.filter((node) => !toRemove.has(node))
        result.reactiveDeclarations = reactiveDeclarations

        estreewalker.walk(scripts[x].children, {
            enter(node, parent) {
                // should now show the Program node for top-level nodes
                if (node.type === 'VariableDeclaration' && parent.type === 'Program') {
                    node.declarations.forEach(decl => {

                        let depVar = result.dependencyTree.get(decl.id.name);
                        depVar.declarationType = node.kind;
                        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${decl.id.name}')`)
                        result.code.dependencyTree.push(`$$_depVar.declarationType = '${node.kind}'`)
                        if (decl.init) {
                            estreewalker.walk(decl.init, {
                                enter(innerNode) {
                                    if (innerNode.type === 'Identifier') {
                                        let _depVar = result.dependencyTree.get(innerNode.name);
                                        _depVar.dependents.variables.add(decl.id.name);
                                        depVar.dependsOn.variables.add(innerNode.name);
                                        result.code.dependencyTree.push(`$$_depVar.dependsOn.variables.add(${innerNode.name})`)
                                        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${innerNode.name}')`)
                                        result.code.dependencyTree.push(`$$_depVar.dependents.variables.add('${decl.id.name}')`)
                                    }
                                }
                            });
                        }


                        // Insert a new statement after this VariableDeclaration node
                        const setReactiveNode = createSetReactiveNode(decl.id.name);

                        // Find the index of the current VariableDeclaration node in parent's body
                        const index = parent.body.indexOf(node);

                        // Insert the setReactive statement right after in the parent's body array
                        if (index !== -1) {
                            parent.body.splice(index + 1, 0, setReactiveNode);
                        }
                    });
                }
            }
        });

        let currentScope = rootScope
        let closestBodyParentStack = [];
        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (node.body && Array.isArray(node.body)) {
                    closestBodyParentStack.push(node);
                }
                if (map.has(node)) currentScope = map.get(node);
                if (
                    //An UpdateExpression (e.g., x++ or --y)
                    node.type === 'UpdateExpression'
                    ||
                    //An AssignmentExpression (e.g., x = 5 or y += 2)
                    node.type === 'AssignmentExpression'
                ) {
                    const names = periscopic.extract_names(
                        node.type === 'UpdateExpression' ? node.argument : node.left
                    );
                    for (const name of names) {
                        if (
                            currentScope.find_owner(name) === rootScope
                            ||
                            globals.has(name)
                        ) {
                            result.willChange.add(name);


                            // Insert a new statement after this VariableDeclaration node
                            const checkReactiveNode = createCheckReactiveNode(name);

                            // Use top of the stack as the closest body parent (Find the index of the current VariableDeclaration node in parent's body)
                            const closestParent = closestBodyParentStack[closestBodyParentStack.length - 1];
                            if (closestParent) {
                                const body = closestParent.body;
                                const index = body.indexOf(parent);

                                // Insert the setReactive statement right after in the parent's body array
                                if (index !== -1) {
                                    body.splice(index + 1, 0, checkReactiveNode);
                                }
                            }
                        }
                    }
                }
            },
            leave(node) {
                if (map.has(node)) currentScope = currentScope.parent;

                if (node.body && Array.isArray(node.body)) {
                    closestBodyParentStack.pop();
                }
            },
        });

        estreewalker.walk(scripts[x].children.body, {
            enter(node, parent) {
                if (parent !== null) {
                    // We are at a child node (first level), so skip its children
                    this.skip();
                }
                // Check if node is a FunctionDeclaration and its parent is Program (global scope)
                if (node.type === 'FunctionDeclaration') {
                    result.functions.add(node.id.name)
                }
            }
        });
        /*
        console.log(inspect(scope, { depth: null, colors: true, showHidden: true }));
        console.log(inspect(map, { depth: null, colors: true, showHidden: true }));
        console.log(inspect(globals, { depth: null, colors: true, showHidden: true }));
        */
       //console.log(inspect(result, { depth: null, colors: true, showHidden: true }))
       script_pos_analyse(scripts[x], result)
    }

    exthtml.forEach(node => traverseExthtml(node, result, 'TARGET'))

    return result
}

function script_pre_analyse(script, result){

}

function script_pos_analyse(script, result){
    if ( script.attrs.some(attr => attr.name == 'context' && attr.value === 'module') ) {
        result.code.shared_state.push(escodegen.generate(script.children))
        return
    }
}

function traverseExthtml(exthtml, result, parent_nm) {
    let variableName = ''
    let reactiveFnName = ''
    try {
        switch (exthtml.type) {
            case 'NEW_LINE':
            case 'SINGLE_LINE_COMMENT':
            case 'MULTIPLE_LINE_COMMENT':
            case 'COMMENT_TEXT':
            case 'SCRIPT_TAG':
            case 'STYLE_TAG':
                return
            case 'DYNAMIC_TEXT_NODE':
                result.code.internal_import.add("text")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                variableName = `$$dyn_txt_${elem_counter++}`
                reactiveFnName = `${variableName}__textContent`
                result.code.elems.push(variableName)
                result.code.create.push(`${variableName} = $$_text(${codeUtils.escapeNewLine(exthtml.value)})`)
                //result.code.update.push(`${variableName}.textContent = \`${exthtml.value}\``)
                let usedVars = extract_relevant_js_parts_evaluated_to_string(exthtml.value, result)
                for (const v of usedVars) {
                    let depVar = result.dependencyTree.get(v)
                    depVar.dependents.texts.add(reactiveFnName)
                    result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
                    result.code.dependencyTree.push(`$$_depVar.dependents.texts.add(${reactiveFnName})`)
                }
                result.code.reactives.push(`function ${reactiveFnName}(){${variableName}.textContent = ${exthtml.value}}\n`)
                result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
                return

            case 'TEXT_NODE':
                result.code.internal_import.add("text")
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                variableName = `$$txt_${elem_counter++}`
                result.code.elems.push(variableName)
                result.code.create.push(`${variableName} = $$_text('${codeUtils.escapeNewLine(exthtml.value)}')`)
                result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
                return

            case 'TEXTAREA_TAG':
                variableName = `$$textarea_${elem_counter++}`
                break
            case 'TITLE_TAG':
                variableName = `$$textarea_${elem_counter++}`
                break
            case 'PLAINTEXT_TAG':
                variableName = `$$plaintext_${elem_counter++}`
                break
            case 'HTML_NESTED_TAG':
                variableName = `$$${exthtml.value.toLowerCase()}_${elem_counter++}`
                break
            case 'SELF_CLOSE_TAG':
                result.code.internal_import.add("append")
                result.code.internal_import.add("detach")
                result.code.internal_import.add("el")
                variableName = `$$${exthtml.value.toLowerCase()}_${elem_counter++}`
                result.code.elems.push(variableName)
                result.code.create.push(`${variableName} = $$_el('${exthtml.value.toLowerCase()}')`)
                exthtml.attrs.forEach(attr => traverseExthtmlAttr(attr, "STATIC", result, variableName, exthtml, parent_nm))
                exthtml.dynamic_attrs.forEach(dynamicAttr => traverseExthtmlAttr(dynamicAttr, "DYNAMIC", result, variableName, exthtml, parent_nm))
                exthtml.event_attrs.forEach(eventAttr => traverseExthtmlEventAttr(eventAttr, "DYNAMIC", result, variableName, parent_nm))
                result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
                result.code.destroy.push(`$$_detach(${variableName})`)
                return
            case 'COMPONENT':

                break
            default:
                throw Error(`${traverseExthtml.name} Error on unexpected type equal ${exthtml.type} and value ${exthtml.value} at line ${exthtml.location.line}`)
        }

        result.code.internal_import.add("el")
        result.code.internal_import.add("append")
        result.code.internal_import.add("detach")
        result.code.elems.push(variableName)
        
        result.code.create.push(`${variableName} = $$_el('${exthtml.value.toLowerCase()}')`)
        exthtml.children.forEach(node => traverseExthtml(node, result, variableName, parent_nm))
        exthtml.attrs.forEach(attr => traverseExthtmlAttr(attr, "STATIC", result, variableName, exthtml, parent_nm))
        exthtml.dynamic_attrs.forEach(dynamicAttr => traverseExthtmlAttr(dynamicAttr, "DYNAMIC", result, variableName, exthtml, parent_nm))
        exthtml.event_attrs.forEach(eventAttr => traverseExthtmlEventAttr(eventAttr, "DYNAMIC", result, variableName, parent_nm))

        result.code.mount.push(`$$_append(${parent_nm},${variableName})`)
        result.code.destroy.push(`$$_detach(${variableName})`)
    } catch (err) {
        let errors = [err, new Error(`${traverseExthtml.name} Error on ${exthtml.type}.${exthtml.value} at line ${exthtml.location.start.line}`)]
        throw new AggregateError(errors)
    }
}

function traverseExthtmlAttr(attr, mode, result, variableName, node, parent_nm) {
    let aValidMode = ['DYNAMIC', 'STATIC']
    if (!aValidMode.includes(mode)) {
        throw new Error(`Invalid mode: ${mode}. Expected one of: ${aValidMode.join(', ')}`);
    }

    switch (attr.category) {
        case "html_global_boolean_attribute":
        case "html_boolean_attribute":
            htmlBooleanAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_data_attribute":
            htmlDataAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_global_non_boolean_attribute":
        case "html_attribute":
            htmlRegularAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "html_media_readonly":
        case "html_video_readonly":
            htmlReadOnlyAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "class_directive":
            htmlClassDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "lang_directive":
            htmlLangDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "custom_attribute":
            htmlCustomAttr(attr, mode, result, variableName, node, parent_nm)
            break
        case "drall_directive":
            htmlDrallDirective(attr, mode, result, variableName, node, parent_nm)
            break
        case "macro_directive":
            htmlMacroDirective(attr, mode, result, variableName, node, parent_nm)
            break
        default:
            throw Error(`${traverseExthtmlAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is of category ${attr.category} not recognized`)
    }
}

function checkMode(mode) {
    let aValidMode = ['DYNAMIC', 'STATIC']

    if (!aValidMode.includes(mode)) {
        throw new Error(`Invalid mode: ${mode}. Expected one of: ${aValidMode.join(', ')}`);
    }
}

function traverseExthtmlEventAttr(eventAttr, mode, result, variableName, parent_nm) {
    checkMode(mode)

    if (mode != "DYNAMIC") {
        throw new Error(`Invalid mode: ${mode} for extHTML event Attribute.}`);
    }


    let modifierChecks = '';
    if (eventAttr.keyboard_modifiers_keys && eventAttr.keyboard_modifiers_keys.length > 0) {
        const mods = eventAttr.keyboard_modifiers_keys.map(key => `event.${key}Key`).join(' && ');
        modifierChecks = mods ? `if (!(${mods})) return;` : '';
    }

    // Build mouse key check if applicable
    let mouseKeyCheck = '';
    if (eventAttr.mouse_keys) {
        // For example, left mouse button check: event.button === 0
        // Map mouse_keys string to event.button number:
        const mouseButtonMap = {
            left: 0,
            middle: 1,
            right: 2
        };
        const btnCode = mouseButtonMap[eventAttr.mouse_keys.toLowerCase()];
        if (btnCode !== undefined) {
            mouseKeyCheck = `if (event.button !== ${btnCode}) return;`;
        }
    }

    let reactiveFnName = `${variableName}__handlerCode`
    // Compose the full event handler code snippet
    // DYNAMIC mode: eventAttr.value is an expression to be evaluated at runtime
    const handlerCode = `
        function ${reactiveFnName}(event) {
            ${modifierChecks}
            ${mouseKeyCheck}
            (${eventAttr.value}) && (${eventAttr.value})(event)
        }
    `.replace(/^\s*[\r\n]/gm, '');

    result.code.reactives.push(`${handlerCode.trim()}\n`)
    result.code.mount.push(`${variableName}.addEventListener('${eventAttr.name}', ${reactiveFnName})`);
    result.code.destroy.push(`${variableName}.removeEventListener('${eventAttr.name}', ${reactiveFnName})`);
}


function htmlBooleanAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    result.code.internal_import.add("setAttr")
    result.code.internal_import.add("rmAttr")

    if (mode == "STATIC") {
        result.code.create.push(`('${attr.value}') ? $$_setAttr(${variableName}, '${attr.name}', '${attr.value}') : $$_rmAttr(${variableName}, '${attr.name}')`)
    } else {
        let reactiveFnName = `${variableName}__${attr.name}`
        let usedVars = extract_relevant_js_parts_evaluated_to_boolean(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
            result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
        }
        result.code.reactives.push(`function ${reactiveFnName}(){\n
            (${attr.value}) ? $$_setAttr(${variableName}, '${attr.name}', ${attr.value} ? "" : false) : $$_rmAttr(${variableName}, '${attr.name}')
        }`)
        result.code.create.push(`${reactiveFnName}()`)
        //result.code.update.push(`(${attr.value}) ? setAttr(${variableName}, '${attr.name}', ${attr.value}) : rmAttr(${variableName}, '${attr.name}')`)
    }
}

function htmlDataAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    // Data attributes are of the form data-xxx
    // They should be set or removed on the element's dataset property
    // For STATIC mode, attr.value is a literal value (string)
    // For DYNAMIC mode, attr.value is an expression to be evaluated at runtime

    const dataKey = attr.name.slice(5) // remove 'data-' prefix

    if (mode === "STATIC") {
        // For static, check if the value is truthy to set or remove dataset property
        result.code.create.push(`('${attr.value}') ? ${variableName}.dataset['${dataKey}'] = '${attr.value}' : delete ${variableName}.dataset['${dataKey}']`)
    } else {
        let reactiveFnName = `${variableName}__dataset`

        let usedVars = extract_relevant_js_parts_evaluated_to_string(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
            result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
        }


        // For dynamic, evaluate expression and set or delete accordingly
        //result.code.update.push(`(${attr.value}) ? ${variableName}.dataset['${dataKey}'] = ${attr.value} : delete ${variableName}.dataset['${dataKey}']`)
        result.code.reactives.push(`function ${reactiveFnName}(){(${attr.value}) ? ${variableName}.dataset['${dataKey}'] = ${attr.value} : delete ${variableName}.dataset['${dataKey}']}`)
    }
}

function htmlClassDirective(attr, mode, result, variableName, node, parent_nm) {
    if (mode != "DYNAMIC") {
        throw Error(`${htmlClassDirective.name} function: Invalid ${mode.toLowerCase()} attribute on class directive as it is only dynamic attribute`)
    }
    let reactiveFnName = `${variableName}__${attr.name}`
    let usedVars = extract_relevant_js_parts_evaluated_to_boolean(attr.value, result)
    for (const v of usedVars) {
        let depVar = result.dependencyTree.get(v)
        depVar.dependents.directives.add(reactiveFnName)
        result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
        result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
    }
    result.code.reactives.push(`function ${reactiveFnName}(){
        (!!(${attr.value})) ? ${variableName}.classList.add('${attr.name.trim()}') : ${variableName}.classList.length === 1 ? $$_rmAttr(${variableName}, '${attr.name}') : ${variableName}.classList.remove('${attr.name}')
    }`)
    //class:xxxxxx
    //result.code.update.push(`(!!(${attr.value})) ? ${variableName}.classList.add('${attr.name}'): ${variableName}.classList.remove('${attr.name}')`)
}

function htmlClassAttr(attr, mode, result, variableName, parent_nm) {
    if (mode === "DYNAMIC") {
        let operations = attr.value.split(",")

        operations.forEach(operation => {
            let [_class, expression] = operation.split(":");
            let reactiveFnName = `${variableName}__${_class}`
            let usedVars = extract_relevant_js_parts_evaluated_to_boolean(expression, result)
            for (const v of usedVars) {
                let depVar = result.dependencyTree.get(v)
                depVar.dependents.directives.add(reactiveFnName)
                result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
                result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
            }
            result.code.reactives.push(`function ${reactiveFnName}(){
                (!!(${expression})) ? ${variableName}.classList.add('${_class.trim()}') : ${variableName}.classList.length === 1 ? $$_rmAttr(${variableName}, '${_class}') : ${variableName}.classList.remove('${_class}')
            }`)

            //result.code.update.push(`(!!(${expression})) ? ${variableName}.classList.add('${_class}'): ${variableName}.classList.remove('${_class}')`)
        });
    } else {
        // Static class attribute: set once on create
        result.code.create.push(`${variableName}.classList.add('${attr.value.split(" ").map(cls => `"${cls.trim()}"`).join(", ")}')`)
    }
}

function htmlRegularAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)
    // Handle special cases for 'class'
    if (attr.name === 'class') {
        htmlClassAttr(attr, mode, result, variableName, parent_nm)
        return
    }
    //style
    if (attr.name === 'style') {
        handleStyleAttr(attr, mode, result, variableName);
        return;
    }

    result.code.internal_import.add("setAttr")
    result.code.internal_import.add("rmAttr")

    if (mode == "STATIC") {
        result.code.create.push(`('${attr.value}') ? $$_setAttr(${variableName}, '${attr.name}', '${attr.value}') : $$_rmAttr(${variableName}, '${attr.name}')`)
    } else {
        let reactiveFnName = `${variableName}__${attr.name}`

        let usedVars = extract_relevant_js_parts_evaluated_to_string(attr.value, result)
        for (const v of usedVars) {
            let depVar = result.dependencyTree.get(v)
            depVar.dependents.directives.add(reactiveFnName)
            result.code.dependencyTree.push(`$$_depVar = $$_dependencyTree.get('${v}')`)
            result.code.dependencyTree.push(`$$_depVar.dependents.directives.add(${reactiveFnName})`)
        }

        result.code.reactives.push(`function ${reactiveFnName}(){
            let cursorPosition
            if ('${node.value}' == 'INPUT' && ${attr.value} && document.activeElement === ${variableName}) {
                cursorPosition = ${variableName}.selectionStart
            }
            (${attr.value}) ? $$_setAttr(${variableName}, '${attr.name}', ${attr.value}) : $$_rmAttr(${variableName}, '${attr.name}')
            if ('${node.value}' == 'INPUT' && ${attr.value} && document.activeElement === ${variableName}) {
                ${variableName}.setSelectionRange(cursorPosition, cursorPosition)
            }
        }`)

        result.code.create.push(`${reactiveFnName}()`)

        //result.code.update.push(`(${attr.value}) ? setAttr(${variableName}, '${attr.name}', ${attr.value}) : rmAttr(${variableName}, '${attr.name}')`)
    }
}

function htmlReadOnlyAttr(attr, mode, result, variableName, node, parent_nm) {
    throw Error(`${htmlReadOnlyAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is readonly attribute`)
}

function htmlCustomAttr(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in customAttr.customAttributes)) {
        throw Error(`${htmlCustomAttr.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is html custom attribute but the compiler could not found it on custom attribute list`)
    }

    customAttr.customAttributes[attr.name](attr, mode, result, variableName, parent_nm)

}

function htmlDrallDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in drall.directives)) {
        throw Error(`${htmlDrallDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    drall.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function htmlMacroDirective(attr, mode, result, variableName, node, parent_nm) {
    checkMode(mode)

    if (!(attr.name in macro.directives)) {
        throw Error(`${htmlMacroDirective.name} function: Invalid ${mode.toLowerCase()} attribute on ${attr.name} as it is macro directive attribute but the compiler could not found it on directive list`)
    }
    macro.directives[attr.name](attr, mode, result, variableName, node, parent_nm)
}

function handleStyleAttr(attr, mode, result, variableName) {
    if (mode === "STATIC") {
        // Static style: attr.value is expected to be a string of CSS declarations
        // Just set the whole style attribute once
        result.code.create.push(`${variableName}.setAttribute('style', '${attr.value}')`);
    } else if (mode === "DYNAMIC") {
        // Dynamic style: attr.value can be string, object, or array
        // We'll generate code to update styles individually

        // The dynamic value is expected to be a JS expression (variable or object/array literal)
        const styleVar = attr.value;

        // Generate code that:
        // - clears previous inline styles
        // - iterates over the style declarations and sets/removes styles accordingly

        // We'll generate code that handles three cases:
        // 1. If styleVar is a string: parse by ';' and split by ':'
        // 2. If styleVar is an array: iterate and split each item by ':'
        // 3. If styleVar is an object: iterate keys and values

        // To keep it simple, generate a helper function in update code:

        //@TODO - See all formats and adapt the code
        result.code.update.push(`
            (function() {
                const el = ${variableName};
                // Clear all previous inline styles
                el.style.cssText = '';
                const styleVal = ${styleVar};
                if (typeof styleVal === 'string') {
                    styleVal.split(';').forEach(decl => {
                        const [key, val] = decl.split(':').map(s => s && s.trim());
                        if(key && val) el.style.setProperty(key, val);
                    });
                } else if (Array.isArray(styleVal)) {
                    styleVal.forEach(decl => {
                        const [key, val] = decl.split(':').map(s => s && s.trim());
                        if(key && val) el.style.setProperty(key, val);
                    });
                } else if (typeof styleVal === 'object' && styleVal !== null) {
                    Object.entries(styleVal).forEach(([key, val]) => {
                        if(val != null) el.style.setProperty(key, val);
                    });
                }
            })()
        `);
    }
}

export function extract_relevant_js_parts_evaluated_to_string(code, result){
    let ast = parseCode(code)
    //console.log(inspect(ast, { depth: null, colors: true }))
    let usedVars = new Set()


    //ExpressionStatement
    estreewalker.walk(ast.body, {
        enter(node) {
            if ( node.name ){
                result.willUseInTemplate.add(node.name)
                usedVars.add(node.name)
            }
        }
    })

    return usedVars
    
    //console.log(inspect(ast, { depth: null, colors: true }))
}

function extract_relevant_js_parts_evaluated_to_boolean(code, result){
    return extract_relevant_js_parts_evaluated_to_string(code, result)
}


function generateCtx(scripts, analysis) {
    return `function ctx(){
        ${Array.from(analysis.undeclared_variables).map((v) => `let ${v};`).join('\n')}
        ${scripts.map(script => escodegen.generate(script.children))}

        return [${[...analysis.declared_variables, ...analysis.undeclared_variables].filter(x => x).join(",")}]
    }
    `
}

//context="module"
function generate4Web(scripts, styles, analysis) {
    //${scripts.filter(script => !script.attrs.some(attr => attr.name === 'context' && attr.value === 'module')).map(script => escodegen.generate(script.children))}
    return `${BANNER}
    import {${Array.from(analysis.code.internal_import).map(name => `${name} as $$_${name}`).join(", ")}} from 'exthtml/src/runtime/dom.js';
    import {setReactive as $$_setReactive, checkReactive as $$_checkReactive} from 'exthtml/src/runtime/reactive2.js';
    import { DependencyTree as $$_DependencyTree } from 'exthtml/src/compiler/internals/variable.js';
    ${analysis.code.imports.join(";\n")};

    // Shared state at the module scope
    ${analysis.code.shared_state.join("\n")}

    export default function(){
        let ${analysis.code.elems.join(',')};

        ${Array.from(analysis.undeclared_variables).map((v) => `let ${v};`).join('\n')}

        let $$_dependencyTree = new $$_DependencyTree();
        let $$_depVar = null;
        let $$changes = new Set();

        let $$_changes = function(nm){
            $$changes.add(nm)
            if(!$$_updating){
                $$_lifecycle.update();
            }
        }

        ${scripts.filter(script => !script.attrs.some(attr => attr.name === 'context' && attr.value === 'module')).map(script => escodegen.generate(script.children))}


        ${analysis.code.reactives.join('\n')}


        let $$_mounted = false;
        let $$_updating = false;
        

        ${analysis.code.dependencyTree.join(';\n')};

        let $$_lifecycle = {
            create() {
                ${analysis.code.create.join(';\n')};
            },
            mount(TARGET) {
                this.create();
                ${analysis.code.mount.join(';\n')};
                $$_mounted = true;
            },
            update() {
                if(!$$_mounted) return;
                if($$_updating) return;
                $$_updating = true;
                ${analysis.code.update.join(';\n')}
                let firstElement;
                while(firstElement = $$changes.values().next().value){
                    $$_depVar = $$_dependencyTree.get(firstElement)
                    for (let key in $$_depVar.dependents) {
                        for (let fn of $$_depVar.dependents[key]) {
                            fn();
                        }
                    }
                    // Remove the first element
                    $$changes.delete(firstElement);
                }

                $$_updating = false;
            },
            destroy(TARGET) {
                ${analysis.code.destroy.join(';\n')};
            },
            capture_state(){
                return { ${[...analysis.declared_variables, ...analysis.undeclared_variables].join(",")} };
            }
        }
        return $$_lifecycle;
    }`
}

function generate4React(scripts, styles, analysis) {

}

function generate4Vue(scripts, styles, analysis) {
    
}

function extractor_sfc_walker(ast, scripts, exthtml, styles, level) {
    level = level || 1
    let output = []
    for (let i = 0; i < ast.length; i++) {
        let node = ast[i];
        if (node.section != 'ExtHTMLDocument') {
            continue
        }

        if (node.type == 'SCRIPT_TAG') {
            scripts.push(node)
        } else if (node.type == 'STYLE_TAG') {
            styles.push(node)
        } else if (node.children){
            extractor_sfc_walker(node.children, scripts, exthtml, styles, level + 1)
            if (level == 1) {
                exthtml.push(node)
            }
            output.push(node)
        }
    }
    return output
}

function print_nodes(ast, indent = 0) {
    const indentStr = '\t'.repeat(indent);

    ast.forEach(node => {
        node_print = { ...node, children: undefined }
        console.log(indentStr + JSON.stringify(node_print, null, indentStr.replace("\t", "    ")))
        // If node has children, recursively print them with increased indent
        if (node.children && node.children.length > 0) {
            printNodes(node.children, indent + 1);
        }
    })
}